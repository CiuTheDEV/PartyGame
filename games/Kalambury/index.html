<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>PartyHUB — Kalambury</title>

  <style>
    *{box-sizing:border-box}
    html,body{height:100%;margin:0}

    /* ANCHOR: BASE_UI */

    /* ANCHOR: CLASS_GLOSSARY (nazwy klas UI — szybka ściąga)
      OVERLAY / NAV:
        .overlay              — pełnoekranowy ekran/popup (display kontrolowane klasą .is-visible)
        .is-visible           — pokazuje overlay
        .is-hidden            — ukrywa element (display:none !important)

      PLANSZA GRY (overlayGame):
        .game-screen          — wrapper pełnego ekranu planszy
        .game-hud             — siatka: top-bar / presenter-slot / players-bar / bottom-bar
        .top-bar              — pasek górny (⚙️)
        .presenter-slot       — sekcja „Prezentuje” + countdown + reveal
        .players-bar          — sekcja z kaflami graczy
        .players-bar-inner    — grid kafli (zmienne CSS: --rows / --cols)
        .bottom-bar           — dolny pasek z przyciskami rundy

      KAFEL GRACZA NA PLANSZY:
        .player-pill          — pojedynczy kafel gracza (avatar + nazwa + punkty)
        .pp-emoji             — lewa część kafla (avatar)
        .pp-meta              — prawa kolumna (nazwa + punkty)
        .pp-name              — pole nazwy
        .pp-score             — pole punktów
        .is-facedown          — stan rewersu (na start rundy / przed odkryciem)
        .roll-focus           — podświetlenie aktualnie odkrywanego kafla (losowanie)
        .presenter-picked     — podświetlenie prezentera (po losowaniu)
        .presenter-pill        — karta prezentera (avatar góra, nazwa dół, bez pkt)

      LISTA GRACZY W USTAWIENIACH:
        .player-row           — wiersz gracza w ustawieniach
        .player-emoji-display — avatar w liście
        .player-name-display  — nazwa w liście
        .player-edit          — edycja gracza
        .player-del           — usuń gracza
    */
    :root{
      /* ANCHOR: THEME_KALAMBURY */
      --bg:#1a1a1a;
      --text:#fff;

      --brand1:#e91e63;
      --brand2:#9b59b6;
      --accent:var(--brand1);
      --accent2:var(--brand2);
      --accentA15:rgba(233,30,99,.15);
      --accent2A15:rgba(155,89,182,.15);
      --focusRing:0 0 0 2px var(--accent);

      /* ANCHOR: BTN_TOKENS */
      --btnShadow:0 8px 16px rgba(0,0,0,.35);
      --btnShadowHover:0 9px 18px rgba(0,0,0,.40);
      --btnLine:rgba(255,255,255,.10);
      --btnInset:0 1px 0 rgba(255,255,255,.06) inset;

      /* ANCHOR: ACTION_TOKENS */
      --danger:#e74c3c;
      --dangerHover:#c0392b;

      /* ANCHOR: SUCCESS_TOKENS */
      --success:#2ecc71;
      --successA15:rgba(46,204,113,.15);
/* ANCHOR: ROUND_RANGE_TOKENS */
      --rangeLabelW:170px;
      --rangeBadgeW:64px;

      /* ANCHOR: GAME_TOKENS */
      --gearSize:clamp(46px,8vmin,60px);
      /* ANCHOR: BAR_HEIGHTS (TOP_BAR = BOTTOM_BAR) */
      --barH:clamp(64px,10vmin,86px);
      --bottomBarH:var(--barH);

      /* ANCHOR: PLAYER_PILL_TOKENS (kafelki graczy — czytelne na TV) */
      --innerPad:clamp(10px,2.2vmin,18px);
      --plGap:clamp(10px,2vmin,16px);
      --plRadius:clamp(14px,2.2vmin,24px);
      --plPad:clamp(10px,2vmin,14px);
      --avFontP:clamp(2.2rem,6.5vmin,3.8rem);
      --nameFontP:clamp(1.05rem,3vmin,1.65rem);
      --scoreFont:clamp(1rem,2.6vmin,1.35rem);
      --cellMin:clamp(140px,22vmin,230px);

      --font-sans:'Segoe UI',Tahoma,sans-serif;
    }

    body{
      font-family:var(--font-sans);
      background:var(--bg);
      color:var(--text);
      text-align:center;
      padding:0;
      margin:0;
      display:flex;
      flex-direction:column;
      min-height:100%;
    }

    /* ANCHOR: OVERLAY_BASE (PartyHUB standard) */
    .overlay{
      position:fixed;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      padding:clamp(18px,4vmin,42px);
      background:rgba(0,0,0,.68);
      backdrop-filter:blur(6px);
      -webkit-backdrop-filter:blur(6px);
      z-index:1200;
    }
    .overlay.is-visible{display:flex}

    /* ANCHOR: OVERLAY_STACKING (game pod popupami) */
    #overlayGame{
      background:transparent;
      backdrop-filter:none;
      -webkit-backdrop-filter:none;
      padding:0;
      z-index:1100;
      align-items:stretch;
      justify-content:stretch;
    }
    #overlayGame.is-visible{display:block}

    #globalSettingsOverlay,
#gameSettingsOverlay,
#rulesOverlay,
#emojiPickerOverlay{z-index:1300}
#confirmOverlay{z-index:1400}

    /* ANCHOR: DEBUG_HUD_UI (podgląd klas w UI) */
    .debug-hud{
      position:fixed;
      left:clamp(10px,2vmin,16px);
      bottom:clamp(10px,2vmin,16px);
      z-index:20000;
      max-width:min(92vw,560px);
      padding:12px 14px;
      border-radius:18px;
      background:linear-gradient(135deg, rgba(0,0,0,.78), rgba(0,0,0,.52));
      border:1px solid rgba(255,255,255,.16);
      outline:1px solid rgba(233,30,99,.10);
      box-shadow:0 16px 36px rgba(0,0,0,.58);
      font-size:clamp(11px,1.35vmin,13px);
      text-align:left;
      line-height:1.35;
      pointer-events:auto;
      user-select:text;
      -webkit-user-select:text;
      backdrop-filter:blur(7px);
      -webkit-backdrop-filter:blur(7px);
      transition:transform .14s ease, opacity .14s ease;
    }
    .debug-hud .dh-line{margin:2px 0}
    .debug-hud .dh-head{display:flex;align-items:center;justify-content:space-between;gap:10px;cursor:grab;user-select:none;-webkit-user-select:none;touch-action:none}
    .debug-hud.dragging .dh-head{cursor:grabbing}
    .debug-hud .dh-head-left{display:inline-flex;align-items:center;gap:8px;min-width:0}
    .debug-hud .dh-drag{display:inline-flex;align-items:center;justify-content:center;width:18px;height:18px;border-radius:7px;background:rgba(255,255,255,.07);border:1px solid rgba(255,255,255,.14);font-weight:1000;opacity:.8;flex:0 0 auto}
    .debug-hud .dh-drag:hover{opacity:1}

    /* ANCHOR: DEBUG_HUD_STAGE_BTN (klikany STAGE — bez F6, bo przeglądarka często przechwytuje) */
    .debug-hud .dh-head-right{display:flex;align-items:center;gap:10px;min-width:0}
    .debug-hud .dh-stage-btn{
      height:22px;
      padding:0 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.16);
      background:rgba(255,255,255,.08);
      color:#fff;
      font-weight:1000;
      font-size:11px;
      letter-spacing:.9px;
      text-transform:uppercase;
      cursor:pointer;
      box-shadow:inset 0 1px 0 rgba(255,255,255,.06);
      flex:0 0 auto;
    }
    .debug-hud .dh-stage-btn:hover{filter:brightness(1.12)}
    .debug-hud .dh-stage-btn:active{transform:scale(.99)}

    .debug-hud .dh-badge{
      display:inline-flex;align-items:center;gap:6px;
      padding:2px 9px;
      border-radius:999px;
      font-size:11px;
      font-weight:1000;
      letter-spacing:.8px;
      text-transform:uppercase;
      color:#fff;
      background:linear-gradient(135deg, rgba(155,89,182,.34), rgba(233,30,99,.26));
      border:1px solid rgba(255,255,255,.16);
      box-shadow:0 10px 18px rgba(0,0,0,.35);
    }

    .debug-hud .dh-tip{margin-top:8px;display:flex;flex-wrap:wrap;gap:8px;color:rgba(255,255,255,.70);font-weight:900;letter-spacing:.1px}
    .debug-hud kbd{display:inline-flex;align-items:center;justify-content:center;min-width:18px;height:18px;padding:0 6px;border-radius:7px;background:rgba(0,0,0,.34);border:1px solid rgba(255,255,255,.14);box-shadow:inset 0 1px 0 rgba(255,255,255,.06);font-size:11px;font-weight:1000;color:#fff}

    .debug-hud .dh-muted{color:rgba(255,255,255,.68)}
    .debug-hud .dh-classes{word-break:break-word}

    /* ANCHOR: DEBUG_HUD_COPY_TOAST */
    .debug-hud.copied::after{
      content:"SKOPIOWANO";
      position:absolute;
      right:10px;
      top:-10px;
      padding:4px 10px;
      border-radius:999px;
      font-size:11px;
      font-weight:1000;
      letter-spacing:.6px;
      background:rgba(0,0,0,.72);
      border:1px solid rgba(255,255,255,.18);
      box-shadow:0 10px 18px rgba(0,0,0,.45);
      pointer-events:none;
    }

    /* ANCHOR: DESIGN_DEBUG_TAGS (etykiety kontenerów data-dbg + data-dbg2) */
    body.design-debug [data-dbg],
    body.design-debug [data-dbg2]{
      position:relative;
      outline:2px dashed var(--dbg-line, rgba(233,30,99,.28));
      outline-offset:-2px;
    }

    /* 1) TAG (LEWY GÓRNY RÓG) — dla głównych kontenerów: data-dbg */
    body.design-debug [data-dbg]::before{
      content:attr(data-dbg);
      position:absolute;
      top:calc(6px + var(--dbgTagShiftY, 0px));
      left:calc(6px + var(--dbgTagShiftX, 0px));
      z-index:2000;
      pointer-events:none;
      padding:2px 8px;
      border-radius:10px;
      font-size:12px;
      font-weight:1000;
      letter-spacing:.7px;
      text-transform:uppercase;
      color:#fff;
      background:rgba(0,0,0,.55);
      border:1px solid rgba(255,255,255,.18);
      box-shadow:0 8px 16px rgba(0,0,0,.35);
      white-space:nowrap;
      max-width:calc(100% - 12px);
      overflow:hidden;
      text-overflow:ellipsis;
    }

    /* 2) TAG (PRAWY DOLNY RÓG) — dla zagnieżdżonych kontenerów: data-dbg2 */
    body.design-debug [data-dbg2]::after{
      content:attr(data-dbg2);
      position:absolute;
      right:calc(6px + var(--dbgTagShiftX, 0px));
      /* ANCHOR: DBG_TAG_SHIFT (zagnieżdżone tagi nie nachodzą — idą "w górę") */
      bottom:calc(6px - var(--dbgTagShiftY, 0px));
      z-index:2000;
      pointer-events:none;
      padding:2px 8px;
      border-radius:10px;
      font-size:11px;
      font-weight:1000;
      letter-spacing:.6px;
      text-transform:uppercase;
      color:#fff;
      background:rgba(0,0,0,.45);
      border:1px solid rgba(255,255,255,.14);
      box-shadow:0 8px 16px rgba(0,0,0,.30);
      opacity:.92;
      white-space:nowrap;
      max-width:calc(100% - 12px);
      overflow:hidden;
      text-overflow:ellipsis;
    }
/* bottom-bar tylko podczas rozdawania pkt (TAK/NIE) */
#overlayGame .game-screen.bb-off { --bottomBarH: 0px; }
#overlayGame .game-screen.bb-off .bottom-bar { display: none; }
    /* ANCHOR: DESIGN_DEBUG_COLORS (każdy kontener = inny kolor linii) */
    /* Główne sekcje planszy gry */
    body.design-debug [data-dbg="GAME_SCREEN"]{ --dbg-line: rgba(46, 204, 113, .60); }
    body.design-debug [data-dbg="GAME_HUD"]{ --dbg-line: rgba(52, 152, 219, .62); }
    body.design-debug [data-dbg="TOP_BAR"]{ --dbg-line: rgba(241, 196, 15, .64); }
    body.design-debug [data-dbg="PRESENTER"]{ --dbg-line: rgba(155, 89, 182, .64); }
    body.design-debug [data-dbg="PLAYERS_BAR"]{ --dbg-line: rgba(231, 76, 60, .62); }
    body.design-debug [data-dbg="BOTTOM_BAR"]{ --dbg-line: rgba(230, 126, 34, .62); }

    /* Zagnieżdżone elementy planszy gry */
    body.design-debug [data-dbg2="TOP_BAR_INNER"]{ --dbg-line: rgba(241, 196, 15, .38); }
    body.design-debug [data-dbg2="PRESENTER_UI"]{ --dbg-line: rgba(155, 89, 182, .38); }
    body.design-debug [data-dbg2="PRESENTER_CARD"]{ --dbg-line: rgba(233, 30, 99, .38); }
    body.design-debug [data-dbg2="COUNTDOWN"]{ --dbg-line: rgba(52, 152, 219, .38); }
    body.design-debug [data-dbg2="REVEAL"]{ --dbg-line: rgba(46, 204, 113, .38); }
    body.design-debug [data-dbg2="PLAYERS_INNER"]{ --dbg-line: rgba(231, 76, 60, .38); }

    /* ANCHOR: DESIGN_DEBUG_STAGE_COLORS (etapy w HUD) */
    body.design-debug [data-dbg2="STAGE_1"]{ --dbg-line: rgba(233, 30, 99, .42); }
    body.design-debug [data-dbg2="STAGE1_GRID"]{ --dbg-line: rgba(233, 30, 99, .32); }
    body.design-debug [data-dbg2="STAGE_2"]{ --dbg-line: rgba(52, 152, 219, .42); }
    body.design-debug [data-dbg2="STAGE2_HEAD"]{ --dbg-line: rgba(52, 152, 219, .30); }
    body.design-debug [data-dbg2="STAGE2_PRESENTER"]{ --dbg-line: rgba(155, 89, 182, .30); }
    body.design-debug [data-dbg2="PRESENTER_PILL"]{ --dbg-line: rgba(155, 89, 182, .26); }
    body.design-debug [data-dbg2="STAGE2_GRID"]{ --dbg-line: rgba(52, 152, 219, .32); }
    body.design-debug [data-dbg2="STAGE2_DRAWER"]{ --dbg-line: rgba(52, 152, 219, .26); }
    body.design-debug [data-dbg2="STAGE2_TOGGLE"]{ --dbg-line: rgba(52, 152, 219, .22); }
    body.design-debug [data-dbg2="STAGE2_META"]{ --dbg-line: rgba(241, 196, 15, .30); }
    body.design-debug [data-dbg2="STAGE2_CHIP"]{ --dbg-line: rgba(241, 196, 15, .22); }
    body.design-debug [data-dbg2="STAGE_CARD"]{ --dbg-line: rgba(255, 255, 255, .16); }

    /* Dodatkowe, często używane kontenery (menu/ustawienia/popupy) */
    body.design-debug [data-dbg2="HOME_CONTAINER"]{ --dbg-line: rgba(155, 89, 182, .34); }
    body.design-debug [data-dbg2="MODE_SETTINGS_CONTAINER"]{ --dbg-line: rgba(52, 152, 219, .34); }
    body.design-debug [data-dbg2="GAME_SETTINGS_CONTAINER"]{ --dbg-line: rgba(241, 196, 15, .34); }
    body.design-debug [data-dbg2="CONFIRM_CONTAINER"]{ --dbg-line: rgba(231, 76, 60, .34); }
    body.design-debug [data-dbg2="EMOJI_PICKER_CONTAINER"]{ --dbg-line: rgba(46, 204, 113, .34); }
    body.design-debug [data-dbg2="RULES_CONTAINER"]{ --dbg-line: rgba(230, 126, 34, .34); }

    /* ANCHOR: PLAYER_PILL_UI (PartyHUB standard — karty graczy + prezenter) */
    .player-pill{
      position:relative;
      width:100%;
      height:100%;
      min-width:0;
      min-height:0;
      display:grid;
      grid-template-columns:1fr 1.55fr;
      grid-template-rows:1fr 1fr;
      gap:var(--plGap);
      padding:var(--plPad);
      border-radius:var(--plRadius);
      background:linear-gradient(135deg, rgba(255,255,255,.08), rgba(0,0,0,.18));
      border:2px solid rgba(255,255,255,.10);
      box-shadow:0 14px 28px rgba(0,0,0,.45), inset 0 1px 0 rgba(255,255,255,.06);
      overflow:hidden;
      transition:transform .16s, box-shadow .16s, border-color .16s, filter .16s;

      /* ANCHOR: PLAYER_PILL_FLIP_PREP (gotowe pod flip rewers/awers) */
      transform-style:preserve-3d;
      perspective:900px;
    }
    .player-pill::before{
      content:"";
      position:absolute;
      inset:0;
      background:
        radial-gradient(120% 120% at 28% 22%, rgba(233,30,99,.12), transparent 62%),
        radial-gradient(140% 140% at 78% 84%, rgba(155,89,182,.10), transparent 64%);
      pointer-events:none;
      z-index:0;
    }

    /* FLIP — zawartość karty (awers) */
    .player-pill > *{position:relative; z-index:1; backface-visibility:hidden; -webkit-backface-visibility:hidden}

    /* FLIP — rewers jako overlay pseudo-element (zawsze istnieje, tylko zmienia opacity/rotację) */
    :where(.players-bar,.stage1-grid) .player-pill::after{
      content:"KALAMBURY";
      position:absolute;
      inset:0;
      display:flex;
      align-items:flex-end;
      justify-content:center;
      padding:14px 12px;
      font-weight:1000;
      letter-spacing:2px;
      font-size:clamp(.8rem, calc(var(--cellMin) * .10), 1.2rem);
      color:rgba(255,255,255,.18);
      text-align:center;
      text-transform:uppercase;
      pointer-events:none;

      background:
        radial-gradient(120% 120% at 32% 22%, rgba(233,30,99,.16), transparent 62%),
        radial-gradient(140% 140% at 70% 82%, rgba(155,89,182,.14), transparent 64%),
        linear-gradient(135deg, rgba(8,8,8,.92), rgba(16,16,16,.88));

      /* domyślnie: schowany (awers) */
      opacity:0;
      transform:rotateY(180deg);
      transform-origin:center;
      backface-visibility:hidden;
      -webkit-backface-visibility:hidden;
      transition:transform .42s cubic-bezier(.2,.9,.2,1), opacity .22s ease;
      z-index:2;
    }

    /* podczas rewersu: pokazuj overlay i chowaj zawartość */
    :where(.players-bar,.stage1-grid) .player-pill.is-facedown::after{
      opacity:1;
      transform:rotateY(0deg);
    }

    :where(.players-bar,.stage1-grid) .player-pill .pp-emoji,
    :where(.players-bar,.stage1-grid) .player-pill .pp-meta,
    :where(.players-bar,.stage1-grid) .player-pill .pp-name,
    :where(.players-bar,.stage1-grid) .player-pill .pp-score{
      transition:opacity .18s ease, transform .42s cubic-bezier(.2,.9,.2,1), filter .18s ease;
      transform:rotateY(0deg);
      backface-visibility:hidden;
      -webkit-backface-visibility:hidden;
    }

    :where(.players-bar,.stage1-grid) .player-pill.is-facedown{
      background:
        radial-gradient(120% 120% at 32% 22%, rgba(233,30,99,.12), transparent 62%),
        radial-gradient(140% 140% at 70% 82%, rgba(155,89,182,.10), transparent 64%),
        linear-gradient(135deg,#1a1a1a,#0f0f0f);
      border-color:rgba(255,255,255,.12);
    }

    :where(.players-bar,.stage1-grid) .player-pill.is-facedown .pp-emoji,
    :where(.players-bar,.stage1-grid) .player-pill.is-facedown .pp-meta,
    :where(.players-bar,.stage1-grid) .player-pill.is-facedown .pp-name,
    :where(.players-bar,.stage1-grid) .player-pill.is-facedown .pp-score{
      opacity:0;
      transform:rotateY(-180deg) scale(.985);
      filter:blur(10px);
    }

    /* badge zawsze nad rewersem */
    .player-pill > .pp-order{z-index:3}

    /* ANCHOR: PLAYER_PILL_INTERACTIONS (plansza: mikro-interakcje) */
    .players-bar .player-pill:active{transform:translateY(0) scale(.995)}

    /* ANCHOR: GUESS_PICK_UI (wybór zgadującego po kliknięciu TAK) */
    .players-bar.is-guess-pick .player-pill{cursor:pointer}
    .players-bar.is-guess-pick .player-pill.guess-disabled{
      opacity:.35;
      filter:grayscale(1) brightness(.85);
      cursor:not-allowed;
      pointer-events:none;
      transform:none;
      border-color:rgba(255,255,255,.10);
    }
    .players-bar.is-guess-pick .player-pill:not(.guess-disabled):hover{
      border-color:rgba(46,204,113,.65);
      box-shadow:0 14px 28px rgba(0,0,0,.45), 0 0 0 3px rgba(46,204,113,.28);
      filter:brightness(1.06);
      transform:translateY(-1px);
    }
    .players-bar.is-guess-pick .player-pill:not(.guess-disabled):active{transform:translateY(0) scale(.995)}
    /* ANCHOR: PRESENTER_CARD_NO_OVERLAP (prezenter nie nachodzi na kafle graczy) */
    .player-pill.presenter-pill{
      align-self:center;
      margin-left:auto;
      margin-right:auto;
      margin-bottom:clamp(10px,2vmin,16px);

      /* ANCHOR: PRESENTER_CARD_SQUARE (nie skaluje się do szerokości presenter_UI) */
      width:min(var(--presenterCardSize), 100%);
      aspect-ratio:1 / 1;
      height:auto;
      max-width:100%;
      max-height:100%;

      /* jak .roll-focus: avatar góra, nazwa dół */
      grid-template-columns:1fr;
      grid-template-rows:1fr auto;

      /* cień trochę słabszy, żeby nie "wchodził" na siatkę graczy */
      box-shadow:0 10px 18px rgba(0,0,0,.38), inset 0 1px 0 rgba(255,255,255,.06);
    }
    .player-pill.presenter-pill .pp-meta,
    .player-pill.presenter-pill .pp-score{display:none}
    .player-pill.presenter-pill .pp-emoji{
      grid-column:1;
      grid-row:1;
      border-radius:calc(var(--plRadius) - 2px);
      font-size:clamp(4.8rem,15vmin,7.8rem);
      line-height:1;
      /* ANCHOR: PRESENTER_AVATAR_NO_FRAME (bez ramki / bez cienia ramki) */
      border:none;
      box-shadow:none;
      background:transparent;
      will-change:transform;
    }

    /* ANCHOR: PRESENTER_AVATAR_PULSE (subtelny puls — respektuje motion-off) */
    body:not(.motion-off) .player-pill.presenter-pill .pp-emoji{
      animation:presenterAvatarPulse 1.65s ease-in-out infinite;
    }
    @keyframes presenterAvatarPulse{
      0%,100%{ transform:scale(1); }
      50%{ transform:scale(1.05); }
    }
    .player-pill.presenter-pill .pp-name{
      grid-column:1;
      grid-row:2;
      text-transform:uppercase;
      letter-spacing:1px;
    }

    /* lewa strefa — avatar (dominujący) */
    .player-pill .pp-emoji{
      grid-column:1;
      grid-row:1 / span 2;
      width:100%;
      height:100%;
      aspect-ratio:auto;
      border-radius:calc(var(--plRadius) - 4px);
      background:transparent; /* ANCHOR: AVATAR_NO_BG (tło tylko pod nazwą i pkt) */
      border:none; /* ANCHOR: AVATAR_NO_BORDER */
      display:grid;
      place-items:center;
      font-size:var(--avFontP);
      box-shadow:none;
    }

    /* prawa kolumna — 2 “pola” (nazwa + punkty) */
    .player-pill .pp-meta{
      grid-column:2;
      grid-row:1 / span 2;
      width:100%;
      min-width:0;
      display:grid;
      grid-template-rows:1fr 1fr;
      gap:var(--plGap);
      padding:0;
      background:none;
      border:none;
      border-radius:0;
      box-shadow:none;
    }

    .player-pill .pp-name,
    .player-pill .pp-score{
      width:100%;
      min-width:0;
      display:grid;
      place-items:center;
      padding:clamp(8px,1.6vmin,12px);
      border-radius:clamp(12px,1.8vmin,16px);
      border:1px solid rgba(255,255,255,.10);
      box-shadow:inset 0 1px 0 rgba(255,255,255,.05);
    }

    /* ANCHOR: PLAYER_NAME_FIELD (czytelne na TV + dopasowanie do pola) */
    .player-pill .pp-name{
      width:100%;
      min-width:0;
      max-width:100%;
      display:grid;
      place-items:center;
      padding:clamp(8px,1.6vmin,12px);
      border-radius:clamp(12px,1.8vmin,16px);
      border:1px solid rgba(255,255,255,.10);
      box-shadow:inset 0 1px 0 rgba(255,255,255,.05);
      background:rgba(0,0,0,.22);
      font-weight:1000;
      font-size:var(--nameFontP);
      letter-spacing:.6px;
      text-transform:uppercase;
      line-height:1.05;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      text-shadow:0 2px 6px rgba(0,0,0,.55);
    }

    /* ANCHOR: PLAYER_SCORE_FIELD (liczba jak timer — bez 'pkt') */
    .player-pill .pp-score{
      background:rgba(0,0,0,.26);
      font-weight:1000;
      font-size:var(--scoreFont);
      letter-spacing:.4px;
      line-height:1;
      color:#fff;
      white-space:nowrap;
      text-shadow:0 2px 6px rgba(0,0,0,.55);
    }

    /* ANCHOR: SCORE_NUM_TIMER_STYLE */
    .player-pill .pp-score .pp-score-num{
      font-weight:1000;
      font-size:clamp(1.35rem,4.2vmin,2.2rem);
      line-height:1;
      letter-spacing:.2px;
      background:linear-gradient(135deg, var(--accent2), var(--accent));
      -webkit-background-clip:text;
      -webkit-text-fill-color:transparent;
      background-clip:text;
      filter:drop-shadow(0 0 14px rgba(233,30,99,.22));
    }

    /* ANCHOR: PLAYER_CARD_REVEAL_TRANSITIONS (płynne odkrywanie kart) */
    .player-pill .pp-emoji,
    .player-pill .pp-meta,
    .player-pill .pp-name,
    .player-pill .pp-score{
      transition:opacity .18s, transform .18s, filter .18s;
    }

    /* ANCHOR: PLAYER_CARD_FACEDOWN (karty rewersem na starcie rundy / przed odkryciem)
       UWAGA: logika flipu jest przygotowana wyżej (pseudo-element ::after + transform). */

    /* ANCHOR: ROLLING_PRESENTER_LAYOUT (podczas LOSOWANIA: avatar + nazwa pod spodem, bez pkt na wszystkich kartach) */
    .players-bar.is-rolling .player-pill{grid-template-columns:1fr;grid-template-rows:1fr auto}
    .players-bar.is-rolling .player-pill .pp-meta{display:contents}
    .players-bar.is-rolling .player-pill .pp-score{display:none}
    .players-bar.is-rolling .player-pill .pp-emoji{grid-column:1;grid-row:1;height:100%}
    .players-bar.is-rolling .player-pill .pp-name{grid-column:1;grid-row:2}

    /* ANCHOR: ROLL_FOCUS_PRESENTER_LAYOUT (podczas losowania: aktualna karta — większy avatar, bez pkt) */
    .players-bar .player-pill.roll-focus{grid-template-columns:1fr;grid-template-rows:1fr auto}
    .players-bar .player-pill.roll-focus .pp-meta{display:contents}
    .players-bar .player-pill.roll-focus .pp-score{display:none}
    .players-bar .player-pill.roll-focus .pp-emoji{grid-column:1;grid-row:1;height:100%;border-radius:calc(var(--plRadius) - 2px);font-size:clamp(3.2rem,10vmin,5.4rem)}
    .players-bar .player-pill.roll-focus .pp-name{grid-column:1;grid-row:2;text-transform:uppercase;letter-spacing:1px}

    /* ANCHOR: PLAYER_CARD_ROLL_STATES (podświetlenie wylosowanego prezentera) */
    .player-pill.presenter-picked{
      border-color:rgba(155,89,182,.65);
      box-shadow:0 12px 22px rgba(0,0,0,.40), 0 0 0 3px var(--accent2);
      transform:translateY(-1px);
      filter:brightness(1.04);
      z-index:1;
    }
    /* ANCHOR: PRESENTER_PICKED_AVATAR_BORDER_OFF (wylosowany prezenter: bez ramki na avatarze) */
    .player-pill.presenter-picked .pp-emoji{
      border:none;
      box-shadow:none;
    }

    /* ANCHOR: DEV_ONLY (widoczne tylko w dev mode) */
    .dev-only{display:none}
    body.design-debug .dev-only{display:flex}

    /* ANCHOR: DEV_STAGE_PILL (Stage w TOP_BAR — tylko dev; otwiera menu pod HUD) */
    #overlayGame .dev-stage{
      align-items:center;
      justify-content:center;
      min-width:0;
      max-width:min(78vw,720px);
    }

    #overlayGame .dev-stage-pill{
      height:var(--gearSize);
      display:flex;
      align-items:center;
      gap:clamp(8px,1.6vmin,12px);
      padding:0 clamp(12px,2.4vmin,18px);
      border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background:linear-gradient(180deg,rgba(255,255,255,.10),rgba(255,255,255,.06));
      box-shadow:0 8px 14px rgba(0,0,0,.22);
      cursor:pointer;
      user-select:none;
      min-width:0;
    }
    #overlayGame .dev-stage-pill:hover{filter:brightness(1.08)}
    #overlayGame .dev-stage-pill:active{transform:translateY(0) scale(.995)}

    #overlayGame .dev-stage-label{
      font-weight:1000;
      letter-spacing:1.2px;
      text-transform:uppercase;
      font-size:clamp(.70rem,1.55vmin,.88rem);
      color:rgba(255,255,255,.62);
      white-space:nowrap;
      flex:0 0 auto;
    }
    #overlayGame .dev-stage-value{
      font-weight:1000;
      letter-spacing:1px;
      text-transform:uppercase;
      font-size:clamp(.95rem,2.35vmin,1.2rem);
      background:linear-gradient(135deg, var(--accent2), var(--accent));
      -webkit-background-clip:text;
      -webkit-text-fill-color:transparent;
      background-clip:text;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      min-width:0;
      max-width:min(46vw,420px);
      filter:drop-shadow(0 0 12px rgba(233,30,99,.18));
    }
    #overlayGame .dev-stage-caret{opacity:.65;font-weight:1000;flex:0 0 auto}

    /* ANCHOR: DEV_STAGE_MENU (panel STAGE pod DEBUG_HUD — nie wpływa na layout) */
    #devStageMenu{
      position:fixed;
      z-index:20001;
      width:min(420px, 92vw);
      padding:12px 12px;
      border-radius:18px;
      background:linear-gradient(135deg, rgba(0,0,0,.78), rgba(0,0,0,.52));
      border:1px solid rgba(255,255,255,.16);
      outline:1px solid rgba(233,30,99,.10);
      box-shadow:0 16px 36px rgba(0,0,0,.58);
      backdrop-filter:blur(7px);
      -webkit-backdrop-filter:blur(7px);
      text-align:left;
      display:none;
      pointer-events:auto;
      user-select:none;
    }
    body.design-debug #devStageMenu{display:block}
    body.design-debug #devStageMenu.is-hidden{display:none!important}

    #devStageMenu .dev-stage-menu-title{
      font-weight:1000;
      letter-spacing:1.4px;
      text-transform:uppercase;
      font-size:12px;
      color:rgba(255,255,255,.78);
      margin:0 0 10px;
    }

    #devStageMenu .dev-stage-menu-row{display:flex;align-items:center;justify-content:space-between;gap:10px;margin:0 0 10px}
    #devStageMenu .dev-stage-menu-current{
      display:inline-flex;align-items:center;justify-content:center;
      padding:6px 10px;border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background:rgba(0,0,0,.22);
      font-weight:1000;letter-spacing:1px;text-transform:uppercase;
      font-size:12px;color:rgba(255,255,255,.74);
      max-width:100%;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;
    }
    #devStageMenu .dev-stage-menu-foot{margin-top:10px;font-size:11px;color:rgba(255,255,255,.55);font-weight:900}

    #devStageMenu .dev-stage-select{
      width:100%;
      height:var(--gearSize);
      border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background:linear-gradient(180deg,rgba(255,255,255,.10),rgba(255,255,255,.06));
      background-color:#0f0f0f;
      color:#fff;
      font-weight:1000;
      letter-spacing:.9px;
      text-transform:uppercase;
      font-size:clamp(.92rem,2.2vmin,1.15rem);
      padding:0 clamp(14px,2.6vmin,18px);
      box-shadow:0 10px 18px rgba(0,0,0,.28);
      cursor:pointer;
      outline:none;
      max-width:100%;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
      appearance:none;
      -webkit-appearance:none;
      -moz-appearance:none;
    }
    #devStageMenu .dev-stage-select:focus-visible{box-shadow:var(--focusRing)}
    #devStageMenu .dev-stage-select option{background:#0f0f0f;color:#fff}

    /* ANCHOR: GEAR_BTN (jak w Tajniakach) */
    .gear-btn{
      width:var(--gearSize);
      height:var(--gearSize);
      border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      background:linear-gradient(180deg,rgba(255,255,255,.10),rgba(255,255,255,.06));
      color:#fff;
      display:grid;
      place-items:center;
      cursor:pointer;
      box-shadow:0 10px 18px rgba(0,0,0,.35);
      transition:transform .14s, box-shadow .14s, filter .14s, background .14s;
      padding:0;
    }
    .gear-btn:hover{filter:brightness(1.1);box-shadow:0 14px 26px rgba(0,0,0,.45)}
    .gear-btn:active{transform:scale(.99)}

    /* ANCHOR: GAME_SETTINGS_OVERLAY_UI (jak w Tajniakach — tylko: dźwięk + kontynuuj + powrót) */
    #gameSettingsOverlay .settings-container{max-width:min(520px,92vw)}
    .game-settings-actions{display:flex;flex-direction:column;gap:14px;margin-top:16px}
    .game-settings-actions button{width:100%}
    /* ANCHOR: RESUME_BTN_TOKEN (Kontynuuj jak Start — wspólny token przycisku potwierdzającego) */

    /* ANCHOR: HOME_UI (IDENTYCZNY LAYOUT JAK TAJNIACY) */
    .home-container{max-width:min(900px,90vw);width:90%}
    .home-version{margin-top:14px;font-size:clamp(.75rem,1.6vmin,.95rem);color:#666;opacity:.85}

    .home-title{
      font-size:clamp(2.5rem,8vmin,5rem);
      margin-bottom:2vh;
      background:linear-gradient(135deg,#9b59b6,#e91e63);
      -webkit-background-clip:text;
      -webkit-text-fill-color:transparent;
      background-clip:text;
      animation:titlePulse 3s ease-in-out infinite;
      filter:drop-shadow(0 0 24px rgba(233,30,99,0.45)) drop-shadow(0 0 52px rgba(155,89,182,0.32));
    }

    @keyframes titlePulse{
      0%,100%{
        transform:scale(1);
        filter:drop-shadow(0 0 24px rgba(233,30,99,0.45)) drop-shadow(0 0 52px rgba(155,89,182,0.32));
      }
      50%{
        transform:scale(1.02);
        filter:drop-shadow(0 0 34px rgba(233,30,99,0.6)) drop-shadow(0 0 76px rgba(155,89,182,0.45));
      }
    }

    /* ANCHOR: MODE_CARDS_UI (ROZWIJANE KARTY JAK W TAJNIACY / 5 SEKUND) */
    .mode-selection{display:flex;flex-direction:column;gap:clamp(10px,2vmin,20px);margin-bottom:3vh}

    .mode-card{
      background:linear-gradient(135deg,#2a2a2a,#1a1a1a);
      border-radius:clamp(12px,2vmin,20px);
      transition:all .3s;
      border:2px solid transparent;
      overflow:hidden;
    }
    .mode-card:hover{box-shadow:0 5px 20px rgba(0,0,0,.4)}

    .mode-card.classic{border-color:var(--accent)}
    .mode-card.wip{border-color:#9E9E9E}

    .mode-header{display:flex;align-items:center;padding:clamp(12px,2.5vmin,25px) clamp(15px,3vmin,30px);position:relative;cursor:pointer}
    .mode-icon{font-size:clamp(2rem,5vmin,3.5rem);position:absolute;left:clamp(15px,3vmin,30px)}
    .mode-title-wrapper{flex:1;display:flex;align-items:center;justify-content:center;gap:clamp(8px,1.5vmin,15px)}
    .mode-title{font-size:clamp(1.3rem,3.5vmin,2.2rem);font-weight:bold}

    .mode-card.classic .mode-title{color:var(--accent)}
    .mode-card.wip .mode-title{color:#9E9E9E}

    .mode-wip-badge{
      background:#9E9E9E;
      color:#1a1a1a;
      font-size:clamp(0.6rem,1.5vmin,0.8rem);
      font-weight:bold;
      padding:clamp(3px,0.5vmin,5px) clamp(8px,1.2vmin,12px);
      border-radius:clamp(4px,0.8vmin,8px);
      text-transform:uppercase;
      letter-spacing:1px;
    }

    .mode-arrow{position:absolute;right:clamp(15px,3vmin,30px);font-size:clamp(0.8rem,2vmin,1.2rem);color:#666;transition:transform .3s ease}
    .mode-card.open .mode-arrow{transform:rotate(180deg)}

    .mode-content{max-height:0;overflow:hidden;transition:max-height 0.5s cubic-bezier(0.4, 0, 0.2, 1);border-top:1px solid transparent}
    .mode-card.open .mode-content{max-height:500px;border-top-color:#333}

    .mode-content-inner{display:flex;flex-direction:row;align-items:flex-end;justify-content:space-between;gap:clamp(15px,3vmin,25px);padding:clamp(12px,2vmin,20px) clamp(15px,3vmin,30px);background:rgba(0,0,0,0.2)}

    .mode-details{flex:1;min-width:0;opacity:0;transform:translateY(-10px);transition:opacity 0.4s ease 0.15s, transform 0.4s ease 0.15s;text-align:left}
    .mode-card.open .mode-details{opacity:1;transform:translateY(0)}

    .mode-description{font-size:clamp(0.9rem,2vmin,1.1rem);color:#aaa;margin-bottom:clamp(6px,1vmin,10px)}

    .mode-features{text-align:left;font-size:clamp(0.8rem,1.8vmin,1rem);color:#888;list-style:none;padding:0;margin:0}
    .mode-features li{margin:clamp(2px,0.5vmin,5px) 0;padding-left:1em;position:relative}
    .mode-features li::before{content:'•';position:absolute;left:0;color:#666}

    .mode-buttons{display:flex;gap:clamp(8px,1.5vmin,12px);flex-shrink:0;align-self:flex-end;opacity:0;transform:translateX(10px);transition:opacity 0.4s ease 0.2s, transform 0.4s ease 0.2s}
    .mode-card.open .mode-buttons{opacity:1;transform:translateX(0)}

    .mode-btn{
      width:clamp(40px,7vmin,55px);
      height:clamp(40px,7vmin,55px);
      border-radius:50%;
      border:2px solid #666;
      background:rgba(0,0,0,0.3);
      color:#aaa;
      font-size:clamp(1.1rem,2.5vmin,1.5rem);
      font-weight:bold;
      cursor:pointer;
      transition:all .2s;
      display:grid;
      place-items:center;
      padding:0;
      line-height:1;
    }

    /* ANCHOR: PLAY_TRIANGLE (grubszy niż emotka, idealnie wycentrowany) */
    .mode-btn.play{--triH:clamp(9px,2.2vmin,12px);--triW:clamp(14px,3vmin,18px)}
    .mode-btn.play .play-tri{width:var(--triW);height:calc(var(--triH) * 2);background:currentColor;clip-path:polygon(0 0, 0 100%, 100% 50%)}

    .mode-btn.info{font-style:italic;font-family:Georgia,'Times New Roman',serif}
    .mode-btn:hover{background:rgba(255,255,255,0.1);border-color:#aaa;color:#fff;transform:scale(1.06)}

    .mode-card.classic .mode-btn.play{border-color:var(--accent);color:var(--accent)}
    .mode-card.classic .mode-btn.play:hover{background:var(--accent);color:#fff}

    .mode-btn.disabled,
    .mode-btn[disabled]{opacity:0.4;cursor:not-allowed}
    .mode-btn.disabled:hover,
    .mode-btn[disabled]:hover{transform:none;background:rgba(0,0,0,0.3);border-color:#666;color:#aaa}

    /* ANCHOR: HOME_BOTTOM_BUTTONS (JAK W TAJNIACY) */
    .home-bottom-buttons{display:flex;gap:clamp(10px,2vmin,20px);margin-top:clamp(20px,4vmin,40px);flex-wrap:wrap;justify-content:center}

    .home-btn{
      background:transparent;
      border:2px solid;
      padding:clamp(10px,1.8vmin,16px) clamp(18px,3vmin,30px);
      font-size:clamp(0.85rem,2.2vmin,1.1rem);
      border-radius:clamp(8px,1.2vmin,12px);
      cursor:pointer;
      transition:all .2s;
      font-weight:500;
    }
    .home-btn:hover{transform:scale(1.03)}

    .home-btn.hub-btn{border-color:#888;color:#888}
    .home-btn.hub-btn:hover{background:#888;color:#fff}
    .home-btn.settings-btn{border-color:#3498db;color:#3498db}
    .home-btn.settings-btn:hover{background:#3498db;color:#fff}

    /* ANCHOR: RULES_UI (JAK W TAJNIACY) */
    .rules-container{background:#2a2a2a;border-radius:clamp(15px,2vmin,25px);padding:clamp(20px,4vmin,40px);max-width:min(600px,90vw);width:90%;max-height:85vh;overflow-y:auto;text-align:left}
    .rules-title{font-size:clamp(1.5rem,4vmin,2.5rem);margin-bottom:clamp(15px,3vmin,25px);text-align:center;background:linear-gradient(135deg,#9b59b6,#e91e63);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text}
    .rules-content{font-size:clamp(0.9rem,2.2vmin,1.1rem);color:#ccc;line-height:1.6}
    .rules-content h3{color:#fff;font-size:clamp(1.1rem,2.5vmin,1.4rem);margin:clamp(15px,2.5vmin,25px) 0 clamp(8px,1.5vmin,12px)}
    .rules-content h3:first-child{margin-top:0}
    .rules-content p{margin:clamp(8px,1.5vmin,12px) 0}
    .rules-content ul{margin:clamp(8px,1.5vmin,12px) 0;padding-left:clamp(20px,3vmin,30px)}
    .rules-content li{margin:clamp(4px,0.8vmin,8px) 0}
    .rules-content .highlight{color:var(--accent);font-weight:bold}
    .rules-container button{display:block;margin:clamp(20px,3vmin,30px) auto 0}

    /* ANCHOR: MODE_SETTINGS_UI (layout z Tajniaków/5s — kontener ustawień) */
    .settings-container{background:#2a2a2a;border-radius:clamp(15px,2vmin,25px);padding:clamp(15px,3vmin,40px);max-width:min(800px,95vw);width:95%;max-height:90vh;overflow-y:auto;overflow-x:hidden}

    /* ANCHOR: SCROLL_SURFACE (wspólne scroll bary w kolorze gry) */
    .scroll-surface{-webkit-overflow-scrolling:touch;scrollbar-width:thin;scrollbar-color:var(--accent) #1a1a1a}
    .scroll-surface::-webkit-scrollbar{width:8px}
    .scroll-surface::-webkit-scrollbar-track{background:#1a1a1a;border-radius:4px}
    .scroll-surface::-webkit-scrollbar-thumb{background:linear-gradient(180deg,var(--accent),var(--accent2));border-radius:4px}
    .scroll-surface::-webkit-scrollbar-thumb:hover{background:linear-gradient(180deg,var(--accent2),var(--accent))}

    .settings-title{font-size:clamp(1.5rem,4vmin,2.5rem);margin-bottom:2vh;background:linear-gradient(135deg,#9b59b6,#e91e63);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text}
    .game-settings{background:#1a1a1a;border-radius:clamp(8px,1.2vmin,15px);padding:clamp(12px,2vmin,25px);margin-bottom:2vh;overflow:hidden}
    .game-settings h3{color:var(--accent2);margin:0 0 clamp(10px,1.5vmin,15px);font-size:clamp(1rem,2.2vmin,1.4rem);text-align:left}

    /* ANCHOR: UTIL_LAYOUT (bez inline styles) */
    .section-head{display:flex;justify-content:space-between;align-items:center;gap:10px}
    .settings-container--sm{max-width:500px;width:min(500px,92vw)}
    .game-settings--flush{margin-bottom:0}
    .setting-row--compact{margin:0 0 10px}
    .setting-row--last{margin:0}
    .btn-grow-1{flex:1}
    .btn-grow-2{flex:2}
    .btn-lg{font-size:clamp(1.1rem,2.6vmin,1.35rem)}

    /* ANCHOR: EMOJI_PICKER_UTIL */
    .card-block{margin-bottom:15px}
    .small{font-size:.9rem;color:#888;text-align:center;margin-bottom:8px}
    .emoji-name-label{display:block;font-size:.9rem;color:#888;margin-bottom:8px;text-align:center}
    .emoji-name-input{width:100%;padding:12px;font-size:1.1rem;border-radius:10px;border:2px solid var(--accent2);background:#111;color:#fff;text-align:center;outline:none}
    .emoji-name-input:focus{box-shadow:var(--focusRing)}
    .emoji-picker-actions{display:flex;gap:10px;justify-content:center;margin-top:16px}

    /* ANCHOR: MODE_SETTINGS_CARDS (kafelki jak w Tajniakach) */
    .settings-accordion{display:flex;flex-direction:column;gap:clamp(10px,2vmin,18px)}
    .setting-card{background:linear-gradient(135deg,#1f1f1f,#121212);border:2px solid #333;border-radius:clamp(12px,2vmin,20px);overflow:hidden;transition:border-color .18s, box-shadow .18s}
    .setting-card.open{border-color:rgba(233,30,99,.55);box-shadow:0 10px 22px rgba(0,0,0,.45) inset, 0 12px 26px rgba(0,0,0,.35)}
    .setting-head{display:flex;align-items:center;gap:10px;padding:clamp(12px,2.2vmin,18px) clamp(14px,2.6vmin,20px);cursor:pointer;position:relative}
    .setting-title{font-weight:900;color:#fff;text-align:left}
    .setting-sub{flex:1;text-align:right;color:#888;font-size:.95rem;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;padding-right:26px}
    .setting-arrow{position:absolute;right:clamp(14px,2.6vmin,20px);color:#666;transition:transform .2s}
    .setting-card.open .setting-arrow{transform:rotate(180deg)}
    .setting-body{max-height:0;overflow:hidden;transition:max-height .35s cubic-bezier(0.4,0,0.2,1);border-top:1px solid transparent}
    .setting-card.open .setting-body{max-height:1200px;border-top-color:#222}
    .setting-body-inner{padding:clamp(12px,2vmin,16px);background:rgba(0,0,0,0.12)}
    .setting-actions{margin-top:12px}
    .setting-actions .btn-new{width:100%}

    #playersList{margin:0}
    .setting-row{display:flex;justify-content:space-between;align-items:center;margin:6px 0;padding:clamp(8px,1.2vmin,12px);background:#2a2a2a;border-radius:clamp(6px,1vmin,10px);flex-wrap:wrap;gap:8px;max-width:100%}
    .setting-row label{font-size:clamp(0.85rem,2vmin,1.2rem);color:#ccc}

    /* ANCHOR: ROUND_RANGE_UI (wspólne dla Czas tury i Limit punktów) */
    .setting-row-range{align-items:center;flex-wrap:nowrap}
    .setting-row-range label{flex:0 0 var(--rangeLabelW);text-align:left}
    .range-wrap{flex:1 1 auto;min-width:0;display:flex;flex-direction:column;gap:6px}
    .range-wrap input[type=range]{width:100%;margin:0;padding:0;background:transparent;accent-color:var(--accent)}
    .range-scale{display:flex;justify-content:space-between;gap:0;color:#777;font-weight:800;font-size:.8rem;user-select:none}
    .range-scale span{flex:0 0 auto;min-width:1px;text-align:center}
    .range-scale span:first-child{text-align:left}
    .range-scale span:last-child{text-align:right}
    .range-scale .scale-off{opacity:0}
    .range-badge{flex:0 0 var(--rangeBadgeW);min-width:var(--rangeBadgeW);display:flex;align-items:center;justify-content:center;background:#111;border:2px solid var(--accent2);border-radius:12px;padding:8px 10px;font-weight:1000}
    @media(max-width:520px){
      .range-scale{font-size:.72rem}
      .setting-row-range{flex-wrap:wrap}
      .setting-row-range label{flex:1 1 100%}
    }

    /* ANCHOR: CATEGORIES_UI */
    .cat-grid{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:10px}
    .cat-chip{padding:10px 10px;border-radius:12px;border:2px solid #333;background:#0f0f0f;color:#ddd;font-weight:700;cursor:pointer;transition:transform .15s,border-color .15s,background .15s;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    .cat-chip:hover{transform:scale(1.02);border-color:#666;background:#1b1b1b}
    .cat-chip.selected{border-color:var(--accent);background:var(--accentA15);color:#fff}
    .cat-actions{display:flex;gap:10px;justify-content:center;align-items:center;flex-wrap:wrap;margin-top:12px}
    @media(max-width:520px){.cat-grid{grid-template-columns:repeat(2,minmax(0,1fr))}}

    /* ANCHOR: PLAYERS_UI (1:1 z 5 Sekund — lista graczy) */
    .player-row{display:flex;align-items:center;gap:12px;padding:clamp(10px,2vmin,15px);background:#2a2a2a;border-radius:clamp(8px,1vmin,12px);margin:clamp(8px,1.5vmin,12px) 0}
    .player-emoji-display{font-size:2rem;width:50px;height:50px;display:flex;align-items:center;justify-content:center;background:#1a1a1a;border-radius:10px;flex:0 0 auto}
    .player-name-display{flex:1;font-size:1.1rem;font-weight:700;color:#fff;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;text-align:left}
    .player-edit,.player-del{width:44px;height:44px;padding:0;display:grid;place-items:center;line-height:1;font-size:1.15rem;border-radius:10px;flex:0 0 auto}
    .player-edit{border:2px solid #444;background:#1b1b1b;color:#fff;cursor:pointer}
    .player-del{border:2px solid rgba(255,255,255,.08);background:#e74c3c;color:#fff;cursor:pointer;transition:transform .2s}
    .player-del:hover{background:#c0392b;transform:scale(1.05)}

    .emoji-tabs{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:10px;justify-content:center;margin-top:12px;width:100%}
    .emoji-tab{width:100%;padding:10px 0;border-radius:14px;border:2px solid #333;background:#111;color:#ddd;font-weight:1000;cursor:pointer;transition:transform .15s,border-color .15s,background .15s;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;min-width:0}
    .emoji-tab:hover{transform:scale(1.02);border-color:#666;background:#1f1f1f}
    .emoji-tab.selected{border-color:var(--accent);background:var(--accentA15);color:#fff}

    /* ANCHOR: EMOJI_PICKER_LAYOUT (scroll tylko na siatce avatarów) */
    /* ANCHOR: EMOJI_PICKER_FIXED_HEIGHT (stała wysokość kontenera — bez skakania tła przy zmianie kategorii) */
    #emojiPickerOverlay .settings-container{display:flex;flex-direction:column;height:min(90vh,720px);max-height:90vh;overflow:hidden}
    #emojiPickerOverlay .emoji-picker-avatars{flex:1 1 auto;min-height:0;display:flex;flex-direction:column}

    /* ANCHOR: EMOJI_GRID_SCROLLFIX (bez pojawiającego się poziomego scrolla przy hover) */
    .emoji-grid{display:grid;grid-template-columns:repeat(6,minmax(0,1fr));gap:10px;margin-top:12px;flex:1 1 auto;min-height:0;overflow-y:auto;overflow-x:hidden;padding:2px 4px 2px 2px}

    .emoji-btn{width:100%;aspect-ratio:1/1;display:flex;align-items:center;justify-content:center;font-size:1.8rem;background:#111;border:2px solid #333;border-radius:14px;cursor:pointer;padding:0;transition:transform .15s,background .15s,border-color .15s}
    .emoji-btn:hover{border-color:var(--accent);background:#1f1f1f;transform:scale(1.04)}
    .emoji-btn.selected{border-color:var(--accent2);background:var(--accent2A15)}
    .emoji-btn.disabled,.emoji-btn:disabled{opacity:.28;filter:grayscale(1);cursor:not-allowed;transform:none!important}
    .emoji-btn.disabled:hover,.emoji-btn:disabled:hover{border-color:#333;background:#111;transform:none}

    /* ANCHOR: TOGGLE_SWITCH (slider on/off) */
    .switch{position:relative;display:inline-block;width:56px;height:30px;flex:0 0 auto}
    .switch input{opacity:0;width:0;height:0}
    .slider{position:absolute;inset:0;cursor:pointer;background:#3a3a3a;transition:.2s;border-radius:999px;border:2px solid #555}
    .slider:before{content:"";position:absolute;height:22px;width:22px;left:4px;top:50%;transform:translateY(-50%);background:#fff;transition:.2s;border-radius:50%}
    .switch input:checked + .slider{background:var(--accentA15);border-color:var(--accent)}
    .switch input:checked + .slider:before{transform:translate(26px,-50%);background:var(--accent)}

    /* ANCHOR: BUTTONS (IDENTYCZNE JAK W TAJNIACY/5s) */
    .button-group{display:flex;gap:clamp(10px,2vmin,20px);margin-top:2vh;flex-wrap:wrap;justify-content:center}

    button{padding:clamp(10px,2vh,20px) clamp(20px,3vw,40px);font-size:clamp(1rem,2.5vmin,1.5rem);border:none;border-radius:clamp(8px,1vmin,15px);font-weight:bold;cursor:pointer;transition:transform .14s, box-shadow .14s}
    button:active{transform:scale(.995)}

    /* ANCHOR: BUTTONS_POLISH (subtelna głębia — bez połysku) */
    :where(.btn-new,.btn-primary,.btn-reset,.btn-ghost,.btn-back){border:1px solid var(--btnLine);box-shadow:var(--btnInset),var(--btnShadow)}
    :where(.btn-new,.btn-primary,.btn-reset,.btn-ghost,.btn-back):hover{box-shadow:var(--btnInset),var(--btnShadowHover);transform:translateY(-.5px)}
    :where(.btn-new,.btn-primary,.btn-reset,.btn-ghost,.btn-back):active{transform:translateY(0) scale(.99)}

    .btn-new,.btn-primary{background:var(--accent);color:#fff}

    /* ANCHOR: CONFIRM_BTN_HOVER_BRIGHTNESS (rozjaśnienie o 10% na hover dla przycisków potwierdzających) */
    :where(.btn-new,.btn-primary){transition:transform .14s, box-shadow .14s, filter .14s}
    :where(.btn-new,.btn-primary):hover:not(:disabled){filter:brightness(1.1)}

    /* ANCHOR: BTN_BACK (powrót — nie jest akcją destrukcyjną) */
    .btn-back{background:linear-gradient(180deg,rgba(255,255,255,.10),rgba(255,255,255,.06));color:#fff;border-color:rgba(155,89,182,.75)}
    .btn-back:hover{background:linear-gradient(180deg,rgba(155,89,182,.92),rgba(155,89,182,.78));color:#fff}

    .btn-reset{background:var(--danger);color:#fff;border-color:rgba(255,255,255,.08)}
    .btn-reset:hover{background:var(--dangerHover)}

    .btn-ghost{background:linear-gradient(180deg,rgba(255,255,255,.10),rgba(255,255,255,.06));color:#fff;border-color:rgba(255,255,255,.16)}
    .btn-ghost:hover{background:rgba(255,255,255,.12);border-color:rgba(255,255,255,.22)}

    .btn-close{margin-top:20px;width:100%}
    .btn-sm{padding:10px 18px;font-size:1rem;border-radius:12px}
    .txt-muted{color:#888;font-size:0.9rem}
    .txt-error{color:#e74c3c!important}
    .mt-10{margin-top:10px}
    .mt-8{margin-top:8px}
    .text-center{text-align:center}
    .is-hidden{display:none!important}
    .confirm-msg{font-size:1.1rem;color:#f39c12;margin:0 0 18px;text-align:center}
    button:disabled{opacity:.45;cursor:not-allowed}

    /* ANCHOR: FOCUS_VISIBLE (spójny focus ring PartyHUB) */
    button:focus-visible,
    .mode-header:focus-visible,
    .setting-head:focus-visible,
    .cat-chip:focus-visible,
    .emoji-btn:focus-visible,
    .emoji-tab:focus-visible,
    .home-btn:focus-visible{outline:none;box-shadow:var(--focusRing)}

    /* ANCHOR: TWEMOJI (TEST) */
    img.emoji{height:1em;width:1em;vertical-align:-0.1em}

    /* ANCHOR: A11Y_REDUCED_MOTION (system + ustawienia gry) */
    body.motion-off *{animation:none!important;transition:none!important;scroll-behavior:auto!important}
    @media (prefers-reduced-motion: reduce){
      body:not(.motion-on) *{animation:none!important;transition:none!important;scroll-behavior:auto!important}
    }

    /* ANCHOR: RANGE_THUMB (subtelny, appkowy) */
    input[type=range]::-webkit-slider-runnable-track{height:6px;border-radius:999px;background:rgba(255,255,255,.10)}
    input[type=range]::-webkit-slider-thumb{-webkit-appearance:none;appearance:none;width:18px;height:18px;border-radius:50%;background:var(--accent);border:2px solid rgba(255,255,255,.22);margin-top:-6px;box-shadow:0 6px 14px rgba(0,0,0,.35)}
    input[type=range]::-moz-range-track{height:6px;border-radius:999px;background:rgba(255,255,255,.10)}
    input[type=range]::-moz-range-thumb{width:18px;height:18px;border-radius:50%;background:var(--accent);border:2px solid rgba(255,255,255,.22);box-shadow:0 6px 14px rgba(0,0,0,.35)}

    @media(max-width:520px){
      .mode-content-inner{flex-direction:column;align-items:stretch}
      .mode-buttons{align-self:center}
      .emoji-grid{grid-template-columns:repeat(5,minmax(0,1fr))}
    }
  

    /* ANCHOR: GAME_SCREEN_LAYOUT_FIX (hotfix po porządkach) */
    .is-hidden{display:none !important}

    #overlayGame{padding:0;overflow:hidden}
    #overlayGame .game-screen{
      position:relative;
      width:100vw;
      height:100vh;
      display:grid;
      grid-template-rows:var(--barH) minmax(0,1fr) var(--bottomBarH);
      align-items:stretch;
      justify-content:stretch;
      overflow:hidden;
    }
/* ANCHOR: GAME_HUD_LAYOUT (zawsze wykorzystuje przestrzeń między TOP i BOTTOM) */
#overlayGame .game-hud{
  grid-row:2;
  min-height:0;
  overflow:hidden;
  display:flex;
  align-items:stretch;
  justify-content:stretch;
  padding:clamp(10px,2vmin,18px);
}
    /* ANCHOR: STAGE_BASE_UI (HUD — neutralny kafelek etapu) */
   #overlayGame .stage{width:100%;height:100%;min-height:0;display:flex;align-items:center;justify-content:center;flex:1}
    #overlayGame .stage-card{
      width:min(640px, 92vw);
      border-radius:clamp(16px,2.2vmin,24px);
      border:1px solid rgba(255,255,255,.12);
      background:linear-gradient(135deg, rgba(233,30,99,.10), rgba(155,89,182,.12));
      box-shadow:0 18px 34px rgba(0,0,0,.50);
      padding:clamp(16px,2.8vmin,26px);
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      gap:clamp(10px,2vmin,16px);
      user-select:none;
      text-align:center;
      overflow:hidden;
    }
    #overlayGame .stage-title{
      font-weight:1000;
      letter-spacing:1px;
      text-transform:uppercase;
      font-size:clamp(1.6rem,5.2vmin,2.8rem);
      line-height:1.02;
      background:linear-gradient(135deg, var(--accent2), var(--accent));
      -webkit-background-clip:text;
      -webkit-text-fill-color:transparent;
      background-clip:text;
      filter:drop-shadow(0 0 16px rgba(233,30,99,.22));
    }
    /* ANCHOR: STAGE_1_UI (Losowanie — karty graczy rewersem) */
    #overlayGame .stage.stage-1{align-items:stretch;justify-content:stretch}
    #overlayGame .stage.stage-1 .stage-card{width:100%;height:100%;max-width:none;justify-content:flex-start;gap:clamp(10px,2vmin,16px)}
    #overlayGame .stage1-head{display:flex;flex-direction:column;align-items:center;gap:clamp(6px,1.2vmin,10px)}
    #overlayGame .stage1-grid{
      width:min(980px,94vw);
      flex:1;
      min-height:0;
      margin:0 auto;
      padding:var(--innerPad);
      border-radius:clamp(16px,2.2vmin,24px);
      background:rgba(0,0,0,.18);
      border:1px solid rgba(255,255,255,.10);
      box-shadow:inset 0 1px 0 rgba(255,255,255,.05);
      --cols:4;
      --rows:2;
      display:grid;
      gap:var(--plGap);
      grid-template-columns:repeat(var(--cols), minmax(0, 1fr));
      grid-template-rows:repeat(var(--rows), minmax(0, 1fr));
      place-content:center;
      align-content:center;
      justify-content:center;
    }
    #overlayGame .stage1-grid .player-pill{min-width:0;min-height:0}

    /* ANCHOR: STAGE1_DECK_MODE (na start: karty leżą na sobie rewersem) */
    #overlayGame .stage1-grid.is-deck{
      display:block;
      position:relative;
    }
    #overlayGame .stage1-grid.is-deck .player-pill{
      position:absolute;
      left:50%;
      top:50%;
      width:clamp(160px, 26vmin, 240px);
      height:clamp(160px, 26vmin, 240px);
      transform:translate(-50%, -50%) rotate(var(--deckRot, 0deg)) translate(var(--deckX, 0px), var(--deckY, 0px));
      transform-origin:center;
      pointer-events:none;
      box-shadow:0 18px 34px rgba(0,0,0,.55), inset 0 1px 0 rgba(255,255,255,.06);
    }
    #overlayGame .stage1-grid.is-deck .player-pill:nth-child(1){--deckRot:-7deg;--deckX:-8px;--deckY:10px}
    #overlayGame .stage1-grid.is-deck .player-pill:nth-child(2){--deckRot:6deg;--deckX:10px;--deckY:4px}
    #overlayGame .stage1-grid.is-deck .player-pill:nth-child(3){--deckRot:-4deg;--deckX:-4px;--deckY:-6px}
    #overlayGame .stage1-grid.is-deck .player-pill:nth-child(4){--deckRot:3deg;--deckX:6px;--deckY:-10px}
    #overlayGame .stage1-grid.is-deck .player-pill:nth-child(5){--deckRot:-2deg;--deckX:-10px;--deckY:0px}
    #overlayGame .stage1-grid.is-deck .player-pill:nth-child(6){--deckRot:2deg;--deckX:8px;--deckY:8px}
    #overlayGame .stage1-grid.is-deck .player-pill:nth-child(7){--deckRot:-1deg;--deckX:-2px;--deckY:-12px}
    #overlayGame .stage1-grid.is-deck .player-pill:nth-child(8){--deckRot:1deg;--deckX:2px;--deckY:12px}

/* ANCHOR: STAGE1_ROLL_FOCUS (skakanie hovera po kartach) */
#overlayGame .stage1-grid.is-rolling{pointer-events:none}

/* motyw gry (accent/gradient) — spójne z Kalamburami */
#overlayGame .stage1-grid .player-pill.roll-focus{
  border-color:rgba(233,30,99,.92);
  box-shadow:
    0 18px 34px rgba(0,0,0,.55),
    0 0 0 4px rgba(233,30,99,.28),
    0 0 34px rgba(233,30,99,.26),
    0 0 28px rgba(155,89,182,.24);
  filter:brightness(1.12) saturate(1.12);
  transform:translateY(-2px) scale(1.02);
  z-index:2;
}

/* ANCHOR: STAGE1_ROLL_FOCUS_PULSE (puls w trakcie losowania — respektuje motion-off) */
body:not(.motion-off) #overlayGame .stage1-grid .player-pill.roll-focus{
  animation:stage1RollPulse .85s ease-in-out infinite;
}
@keyframes stage1RollPulse{
  0%,100%{
    box-shadow:
      0 18px 34px rgba(0,0,0,.55),
      0 0 0 4px rgba(233,30,99,.26),
      0 0 30px rgba(155,89,182,.22),
      0 0 24px rgba(233,30,99,.22);
  }
  50%{
    box-shadow:
      0 18px 34px rgba(0,0,0,.55),
      0 0 0 4px rgba(155,89,182,.24),
      0 0 30px rgba(233,30,99,.26),
      0 0 24px rgba(155,89,182,.22);
  }
}

    /* ANCHOR: STAGE1_PICKED_LAYOUT (wylosowana karta: tylko avatar + nazwa pod spodem) */
    #overlayGame .stage1-grid .player-pill.stage1-picked{
      grid-template-columns:1fr;
      grid-template-rows:1fr auto;
    }
    #overlayGame .stage1-grid .player-pill.stage1-picked .pp-meta{display:contents}
    #overlayGame .stage1-grid .player-pill.stage1-picked .pp-score{display:none}
    #overlayGame .stage1-grid .player-pill.stage1-picked .pp-emoji{
      grid-column:1;
      grid-row:1;
      height:100%;
      border-radius:calc(var(--plRadius) - 2px);
      font-size:clamp(3.2rem,10vmin,5.4rem);
    }
    #overlayGame .stage1-grid .player-pill.stage1-picked .pp-name{
      grid-column:1;
      grid-row:2;
      text-transform:uppercase;
      letter-spacing:1px;
    }

    /* ANCHOR: STAGE1_ORDER_BADGE (numer kolejności na rewersie) */
#overlayGame .pp-order{
  position:absolute;
  top:clamp(6px,1.2vmin,10px);
  right:clamp(6px,1.2vmin,10px);
  width:clamp(26px,4.6vmin,40px);
  height:clamp(26px,4.6vmin,40px);
  border-radius:999px;
  display:grid;
  place-items:center;
  font-weight:1000;
  font-size:clamp(.85rem,2.6vmin,1.2rem);
  letter-spacing:.5px;
  background:linear-gradient(135deg, rgba(155,89,182,.26), rgba(233,30,99,.18));
  border:1px solid rgba(233,30,99,.55);
  box-shadow:0 10px 18px rgba(0,0,0,.45), 0 0 18px rgba(233,30,99,.12);
  z-index:3;
  user-select:none;
  pointer-events:none;
}
#overlayGame .pp-order.is-hidden{display:none}

    /* ANCHOR: BOTTOM_BAR_ACTIONS (2 przyciski w dolnym barze) */
    #overlayGame .bottom-bar .bb-actions{
      width:min(980px,94vw);
      display:flex;
      align-items:center;
      justify-content:center;
      gap:clamp(10px,2vmin,16px);
    }
    #overlayGame .bottom-bar .bb-actions button{
      width:100%;
      max-width:none;
      padding:clamp(12px,2.2vmin,18px) clamp(16px,3vmin,28px);
      font-size:clamp(1.05rem,2.8vmin,1.35rem);
      line-height:1;
    }
    #overlayGame .bottom-bar .bb-actions .bb-side{flex:1;min-width:0}
    #overlayGame .bottom-bar .bb-actions .bb-main{flex:2;min-width:0}

    /* ANCHOR: STAGE_2_UI (Start rundy — pokazuje kolejność + aktualnego prezentera) */
    #overlayGame .stage.stage-2{align-items:stretch;justify-content:stretch}
    #overlayGame .stage.stage-2 .stage-card{width:100%;height:100%;max-width:none;justify-content:flex-start;gap:clamp(10px,2vmin,16px)}
    #overlayGame .stage2-head{
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:clamp(6px,1.2vmin,10px);
      width:100%;
      flex:1;
      min-height:0;
    }
    #overlayGame .stage2-sub{
      font-weight:1000;
      letter-spacing:1.2px;
      text-transform:uppercase;
      font-size:clamp(.92rem,2.4vmin,1.15rem);
      opacity:.78;
    }

    /* ANCHOR: TOP_BAR_META (info rundy w TOP_BAR podczas STAGE 2) */
    #overlayGame .top-stage-meta{
      grid-column:1;
      justify-self:start;
      align-self:center;
      display:flex;
      flex-wrap:nowrap;
      align-items:center;
      justify-content:flex-start;
      gap:clamp(8px,1.6vmin,12px);
      min-width:0;
      max-width:100%;
      overflow-x:auto;
      overflow-y:hidden;
      padding-right:clamp(6px,1.2vmin,10px);
      scrollbar-width:none;
      user-select:none;
    }
    #overlayGame .top-stage-meta::-webkit-scrollbar{display:none}

    #overlayGame .stage2-chip{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:clamp(8px,1.6vmin,10px);
      padding:clamp(5px,1.05vmin,8px) clamp(8px,1.7vmin,12px);
      border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background:linear-gradient(180deg,rgba(255,255,255,.10),rgba(255,255,255,.06));
      box-shadow:0 10px 18px rgba(0,0,0,.28);
      min-width:0;
      max-width:100%;
    }
    #overlayGame .stage2-chip .k{
      font-weight:1000;
      letter-spacing:1px;
      text-transform:uppercase;
      font-size:clamp(.62rem,1.55vmin,.82rem);
      color:rgba(255,255,255,.62);
      white-space:nowrap;
      flex:0 0 auto;
    }
    #overlayGame .stage2-chip .v{
      font-weight:1000;
      letter-spacing:.6px;
      text-transform:uppercase;
      font-size:clamp(.74rem,1.75vmin,.95rem);
      background:linear-gradient(135deg, var(--accent2), var(--accent));
      -webkit-background-clip:text;
      -webkit-text-fill-color:transparent;
      background-clip:text;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      min-width:0;
      max-width:min(26vw, 280px);
      filter:drop-shadow(0 0 12px rgba(233,30,99,.14));
    }
    #overlayGame .stage2-presenter{
      position:relative;
      margin-top:clamp(6px,1.2vmin,10px);

      /* ANCHOR: STAGE2_PRESENTER_SQUARE_CLOSED
         Gdy szuflada graczy jest ZAMKNIĘTA: prezenter ma być DUŻY i KWADRATOWY.
         (Rozmiar oparty o vmin, żeby dobrze wyglądało na TV i nie wychodziło poza HUD.) */
      width:min(64vmin, 520px, 100%);
      aspect-ratio:1 / 1;

      display:grid;
      place-items:center;
      padding:clamp(6px,1.2vmin,10px);

      flex:1;
      min-height:0;

      /* ANCHOR: STAGE2_PRESENTER_SCALE_WITH_SHEET */
      transform:translateY(0) scale(1);
      transform-origin:center top;
      transition:
        transform .42s cubic-bezier(.2,.9,.2,1),
        opacity  .42s cubic-bezier(.2,.9,.2,1),
        filter   .42s cubic-bezier(.2,.9,.2,1);
    }

    /* W STAGE 2: karta prezentera wypełnia kwadrat .stage2-presenter */
    #overlayGame .stage.stage-2 .stage2-presenter .player-pill.presenter-pill{
      width:100%;
      height:100%;
      max-width:none;
      max-height:none;
      margin:0;
      align-self:stretch;
      justify-self:stretch;
    }
    #overlayGame .stage.stage-2 .stage2-presenter .player-pill.presenter-pill .pp-emoji{
      /* większy avatar w Stage 2 (na TV) */
      font-size:clamp(6.2rem, 22vmin, 10rem);
    }
    #overlayGame .stage.stage-2 .stage2-presenter .player-pill.presenter-pill .pp-name{
      font-size:clamp(1.15rem,3.4vmin,1.9rem);
    }


    /* ANCHOR: STAGE2_PRESENTER_LABEL (nad kartą prezentera — w kolorystyce gry) */
    #overlayGame .stage2-presenter-label{
      position:absolute;
      top:clamp(6px,1.2vmin,12px);
      left:50%;
      transform:translateX(-50%);
      font-weight:1000;
      letter-spacing:2px;
      text-transform:uppercase;
      font-size:clamp(1rem,3vmin,1.4rem);
      background:linear-gradient(135deg, var(--accent2), var(--accent));
      -webkit-background-clip:text;
      -webkit-text-fill-color:transparent;
      background-clip:text;
      filter:drop-shadow(0 0 14px rgba(233,30,99,.18));
      pointer-events:none;
      user-select:none;
      z-index:2;
    }
/* (opcjonalnie) gdy sheet otwarty — prezenter i tak jest chowamy, ale zmniejszamy bazę dla płynniejszego przejścia */
    #overlayGame .stage.stage-2 .stage-card.stage2-sheet-open .stage2-presenter{
      width:min(44vmin, 360px, 100%);
    }

    /* gdy szuflada graczy jest otwarta — chowaj cały blok prezentera (sheet przykrywa cały HUD) */
    #overlayGame .stage.stage-2 .stage-card.stage2-sheet-open .stage2-head{
      opacity:0;
      transform:translateY(-8px) scale(.985);
      filter:blur(10px);
      pointer-events:none;
    }
    #overlayGame .stage2-grid{
      width:min(980px,94vw);
      flex:1;
      min-height:0;
      margin:0 auto;
      padding:var(--innerPad);
      border-radius:clamp(16px,2.2vmin,24px);
      background:rgba(0,0,0,.18);
      border:1px solid rgba(255,255,255,.10);
      box-shadow:inset 0 1px 0 rgba(255,255,255,.05);
      --cols:4;
      --rows:2;
      display:grid;
      gap:var(--plGap);
      grid-template-columns:repeat(var(--cols), minmax(0, 1fr));
      grid-template-rows:repeat(var(--rows), minmax(0, 1fr));
      place-content:center;
      align-content:center;
      justify-content:center;
    }
    #overlayGame .stage2-grid .player-pill{min-width:0;min-height:0}
/* ANCHOR: STAGE2_SHEET (nowoczesna szuflada z dołu — pulsująca strzałka ^)
   WYMAGANIE: po otwarciu karty graczy mają przykryć CAŁY GAME_HUD, chowając .stage2-presenter.
*/
#overlayGame .stage.stage-2 .stage-card{
  position:relative;
  overflow:hidden;

  /* tokeny szuflady */
  --sheetPeek: clamp(48px, 7vmin, 66px);
  --sheetRadius: clamp(18px, 2.4vmin, 26px);

  /* zostaw miejsce na „peek” u dołu, żeby nie nachodziło na prezentera gdy zamknięte */
  padding:clamp(16px,2.8vmin,26px);
  padding-bottom:calc(clamp(16px,2.8vmin,26px) + var(--sheetPeek));
  box-sizing:border-box;
}

/* szuflada pełnoekranowa (cover HUD) — wysuwa się z dołu */
#overlayGame .stage2-sheet{
  position:absolute;
  inset:0;
  width:100%;
  height:100%;
  z-index:10;

  transform:translateY(calc(100% - var(--sheetPeek)));
  transition:transform .42s cubic-bezier(.2,.9,.2,1);

  border-radius:var(--sheetRadius);
  border:1px solid rgba(255,255,255,.12);
  background:
    radial-gradient(120% 120% at 18% 14%, rgba(233,30,99,.14), transparent 60%),
    radial-gradient(120% 120% at 82% 86%, rgba(155,89,182,.12), transparent 62%),
    linear-gradient(180deg, rgba(0,0,0,.48), rgba(0,0,0,.78));
  box-shadow:0 -18px 34px rgba(0,0,0,.55);
  backdrop-filter:blur(10px);
  -webkit-backdrop-filter:blur(10px);

  display:flex;
  flex-direction:column;
  overflow:hidden;
}
#overlayGame .stage2-sheet.is-open{transform:translateY(0)}

/* stary selektor (w razie gdyby coś jeszcze go używało) */
#overlayGame .stage2-drawer{all:unset}

/* uchwyt + caret (na górze sheet; gdy sheet zamknięty, uchwyt jest widoczny na dole HUD) */
#overlayGame .stage2-sheet-handle{
  height:var(--sheetPeek);
  width:100%;
  padding:0;
  border:0;
  background:linear-gradient(180deg,rgba(255,255,255,.10),rgba(255,255,255,.06));
  color:#fff;
  cursor:pointer;
  position:relative;
  display:flex;
  align-items:center;
  justify-content:center;
}
#overlayGame .stage2-sheet-handle:hover{filter:brightness(1.08)}
#overlayGame .stage2-sheet-handle:active{transform:scale(.995)}

/* „grab handle” — delikatna kreska */
#overlayGame .stage2-sheet-handle::before{
  content:"";
  position:absolute;
  left:50%;
  top:50%;
  transform:translate(-50%,-50%);
  width:clamp(72px, 16vmin, 140px);
  height:6px;
  border-radius:999px;
  background:rgba(255,255,255,.12);
  box-shadow:inset 0 1px 0 rgba(255,255,255,.10);
  opacity:.55;
}

/* pulsująca strzałka ^ */
#overlayGame .stage2-sheet-caret{
  position:relative;
  z-index:1;
  font-weight:1000;
  font-size:clamp(1.4rem,4.2vmin,2.2rem);
  opacity:.92;
  transform:translateY(-3px);
  transition:transform .22s ease, opacity .22s ease, filter .22s ease;
  filter:drop-shadow(0 12px 18px rgba(0,0,0,.38));
}
#overlayGame .stage2-sheet.is-open .stage2-sheet-caret{
  transform:translateY(3px) rotate(180deg);
  opacity:.96;
}

/* hint pulse tylko gdy zamknięte i motion ON */
body:not(.motion-off) #overlayGame .stage2-sheet:not(.is-open) .stage2-sheet-caret{
  animation:stage2CaretPulse 1.15s ease-in-out infinite;
}
@keyframes stage2CaretPulse{
  0%,100%{
    transform:translateY(-3px) scale(1);
    opacity:.86;
    filter:drop-shadow(0 12px 18px rgba(0,0,0,.38));
  }
  50%{
    transform:translateY(-10px) scale(1.06);
    opacity:1;
    filter:
      drop-shadow(0 0 18px rgba(233,30,99,.26))
      drop-shadow(0 12px 18px rgba(0,0,0,.38));
  }
}

/* zawartość szuflady */
#overlayGame .stage2-sheet-body{
  flex:1;
  min-height:0;
  padding:var(--innerPad);
  padding-top:clamp(10px,2vmin,14px);
  overflow:auto;
  scrollbar-width:thin;
  scrollbar-color:var(--accent) rgba(0,0,0,.0);
}
#overlayGame .stage2-sheet:not(.is-open) .stage2-sheet-body{
  opacity:0;
  pointer-events:none;
}

/* w środku: grid graczy (bez zmian układu) */
#overlayGame .stage2-sheet .stage2-grid{width:100%}



    #overlayGame .top-bar{
      grid-row:1;
      height:var(--barH);
      display:flex;
      align-items:center;
      justify-content:flex-end;
      /* ANCHOR: BAR_PADDING (bez pionowego paddingu — żeby nie "pchać" wysokości) */
      padding:0 clamp(12px,2.4vmin,18px);
    }
    #overlayGame .top-bar-inner{
      width:100%;
      display:grid;
      grid-template-columns:1fr auto 1fr;
      align-items:center;
      gap:clamp(10px,2vmin,16px);
      min-width:0;
    }
/* ANCHOR: TOP_BAR_STAGE_TITLE (tytuł etapu: LOSOWANIE / PREZENTUJE) */
    #overlayGame .top-title{
      grid-column:2;
      justify-self:center;
      align-self:center;
      min-width:0;
      padding:0 clamp(10px,2.2vmin,14px);
      border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background:linear-gradient(180deg,rgba(255,255,255,.10),rgba(255,255,255,.06));
      box-shadow:0 10px 18px rgba(0,0,0,.28);
      font-weight:1000;
      letter-spacing:1.6px;
      text-transform:uppercase;
      font-size:clamp(.92rem,2.6vmin,1.25rem);
      line-height:1;
      color:#fff;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    #overlayGame .top-title.is-hidden{display:none!important}

    /* w dev: pokazujemy przełącznik stage, a nie tytuł */
    body.design-debug #overlayGame .top-title{display:none}

    #overlayGame .top-bar-inner .gear-btn{grid-column:3;justify-self:end}    /* ANCHOR: PRESENTER_SLOT_BASE (czysta plansza — wrapper rzędu 2) */
    #overlayGame .presenter-slot{
      grid-row:2;
      min-height:0;
      padding:clamp(8px,1.8vmin,14px) clamp(12px,2.4vmin,18px);
      display:flex;
      align-items:center;
      justify-content:center;
    }

    /* ANCHOR: PRESENTER_UI_WRAP (centrowanie + brak wychodzenia poza PRESENTER_UI) */
    #overlayGame .presenter-ui{
      width:min(60%, var(--presenterTileW));
      margin:0 auto;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      gap:clamp(10px,2vmin,16px);
      overflow:hidden;
      min-width:0;
      box-sizing:border-box;
      padding-inline:clamp(4px,1vmin,10px);
    }

    /* ANCHOR: PRESENTER_TITLE_BRAND (napis "Prezentuje" — większy + styl jak liczba w turn_timer) */
    #overlayGame .presenter-title{
      font-weight:1000;
      letter-spacing:2px;
      text-transform:uppercase;
      font-size:clamp(1.6rem,5.2vmin,2.8rem);
      line-height:1;
      user-select:none;

      /* styl jak .countdown-num (gradient text) */
      background:linear-gradient(135deg, var(--accent2), var(--accent));
      -webkit-background-clip:text;
      -webkit-text-fill-color:transparent;
      background-clip:text;
      filter:drop-shadow(0 0 16px rgba(233,30,99,.22));
      text-shadow:0 2px 10px rgba(0,0,0,.55);
    }

    /* ANCHOR: PRESENTER_SLOT_EMPTY_COLLAPSE (przed losowaniem kolejności) */
    #overlayGame .presenter-slot.is-empty{display:none}

    /* BOTTOM BAR buttons visibility */
    .btn-show-password.is-hidden,.presenter-draw-btn.is-hidden{display:none !important}

    /* BOTTOM BAR button sizing */
    #overlayGame .bottom-bar .presenter-draw-btn,
    #overlayGame .bottom-bar .btn-show-password,
    #overlayGame .bottom-bar .btn-roll-order{
      width:min(520px,94vw);
      max-width:100%;
      padding:clamp(12px,2.2vmin,18px) clamp(16px,3vmin,28px);
      font-size:clamp(1.05rem,2.8vmin,1.35rem);
      line-height:1;
    }

    #overlayGame .players-bar{
      grid-row:3;
      min-height:0;
      padding:clamp(8px,1.8vmin,14px) clamp(12px,2.4vmin,18px) clamp(10px,2.4vmin,18px);
      display:flex;
      align-items:stretch;
      justify-content:center;
      overflow:hidden;
    }
    #overlayGame .players-bar-inner{
      width:min(980px,94vw);
      height:100%;
      min-height:0;
      margin:0 auto;
      padding:var(--innerPad);
      overflow:hidden;
      box-sizing:border-box;

      /* ANCHOR: PLAYERS_GRID (stabilny układ — kafle nigdy nie wychodzą poza PLAYERS_INNER) */
      --cols:4;
      --rows:2;
      display:grid;
      gap:var(--plGap);
      grid-template-columns:repeat(var(--cols), minmax(0, 1fr));
      grid-template-rows:repeat(var(--rows), minmax(0, 1fr));
      place-content:center;
      align-content:center;
      justify-content:center;
    }

    /* BOTTOM BAR */
    #overlayGame .bottom-bar{
      grid-row:3;
      height:var(--bottomBarH);
      display:flex;
      align-items:center;
      justify-content:center;
      /* ANCHOR: BAR_PADDING (TOP/BOTTOM takie samo) */
      padding:0 clamp(12px,2.4vmin,18px);
    }


    /* ANCHOR: COUNTDOWN_AND_REVEAL_UI */
    .is-hidden{display:none !important}

    /* Wspólny kafelek pod prezenterem (reveal / countdown / turn_timer) */
    :root{
      --presenterTileW:min(560px,92vw);
      --presenterTileH:clamp(250px,34vmin,380px);

      /* ANCHOR: PRESENTER_CARD_SIZE (bardziej kwadratowa karta prezentera) */
      --presenterCardSize:clamp(158px,19.5vmin,245px);
      --presenterCardW:min(var(--presenterCardSize),92vw);
    }

    .countdown-wrap,
    .reveal-wrap{
      width:var(--presenterTileW);
      height:var(--presenterTileH);
      margin:clamp(10px,2vmin,16px) auto 0;
      border-radius:clamp(14px,2vmin,22px);
      border:1px solid rgba(255,255,255,.12);
      background:linear-gradient(135deg, rgba(233,30,99,.12), rgba(155,89,182,.14));
      box-shadow:0 18px 34px rgba(0,0,0,.50);
      padding:clamp(14px,2.4vmin,22px) clamp(16px,2.8vmin,26px);
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      gap:clamp(8px,1.6vmin,12px);
      user-select:none;
      text-align:center;
    }

    /* reveal ma dodatkowy odstęp na elementy */
    .reveal-wrap{gap:clamp(8px,1.6vmin,12px)}

    /* ANCHOR: COUNTDOWN_TYPO (Countdown + Turn Timer — przywrócone ustawienia czcionek) */
    .countdown-lead{
      font-weight:1000;
      letter-spacing:1px;
      text-transform:uppercase;
      font-size:clamp(1.05rem,3.1vmin,1.45rem);
      opacity:.92;
      text-shadow:0 2px 10px rgba(0,0,0,.55);
    }
    .countdown-num{
      font-weight:1000;
      font-size:clamp(4.2rem,14vmin,7.6rem);
      line-height:1;
      letter-spacing:1px;
      font-variant-numeric:tabular-nums;
      background:linear-gradient(135deg, var(--accent2), var(--accent));
      -webkit-background-clip:text;
      -webkit-text-fill-color:transparent;
      background-clip:text;
      filter:drop-shadow(0 0 16px rgba(233,30,99,.22));
    }
    .countdown-tip{
      max-width:min(64ch, 92%);
      font-weight:850;
      font-size:clamp(.95rem,2.4vmin,1.2rem);
      line-height:1.25;
      opacity:.78;
      text-shadow:0 2px 10px rgba(0,0,0,.55);
    }
    #turnTimerWrap .countdown-tip{opacity:.85;letter-spacing:.4px}

    /* ANCHOR: TURN_TIMER_TYPO_OVERRIDES (większe napisy w kafelku timera tury) */
    #turnTimerWrap .countdown-lead{
      font-size:clamp(1.25rem,3.8vmin,1.85rem);
      letter-spacing:1.4px;
    }
    #turnTimerWrap .countdown-num{
      font-size:clamp(4.8rem,16vmin,8.4rem);
    }
    #turnTimerWrap .countdown-tip{
      font-size:clamp(1.05rem,2.9vmin,1.35rem);
      opacity:.88;
    }

    .reveal-wrap{
      width:min(560px,92vw);
      margin:clamp(10px,2vmin,16px) auto 0;
      border-radius:clamp(14px,2vmin,22px);
      border:1px solid rgba(255,255,255,.12);
      background:linear-gradient(135deg, rgba(233,30,99,.12), rgba(155,89,182,.14));
      box-shadow:0 18px 34px rgba(0,0,0,.50);
      padding:clamp(14px,2.4vmin,22px) clamp(16px,2.8vmin,26px);
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      gap:clamp(8px,1.6vmin,12px);
      user-select:none;
      text-align:center;
    }
    .reveal-player{
      font-weight:1000;
      font-size:clamp(1.2rem,3.6vmin,1.8rem);
      opacity:.95;
      text-transform:uppercase;
      letter-spacing:1px;
    }
    /* ANCHOR: REVEAL_TIMER_UI (czas widoczności hasła) */
    .reveal-timer{
      display:flex;
      align-items:baseline;
      justify-content:center;
      gap:8px;
      margin-top:-2px;
      user-select:none;
      text-transform:uppercase;
      letter-spacing:1px;
      font-weight:1000;
      opacity:.88;
    }
    .reveal-timer-label{font-size:clamp(.85rem,2.35vmin,1.05rem)}
    .reveal-timer-num{
      font-size:clamp(1.15rem,3.8vmin,1.85rem);
      line-height:1;
      background:linear-gradient(135deg, var(--accent2), var(--accent));
      -webkit-background-clip:text;
      -webkit-text-fill-color:transparent;
      background-clip:text;
      filter:drop-shadow(0 0 14px rgba(233,30,99,.20));
    }
    .reveal-timer-unit{font-size:clamp(.85rem,2.35vmin,1.05rem);opacity:.85}

    .reveal-lead{opacity:.85;font-weight:900;letter-spacing:.4px}
    .reveal-word{
      font-weight:1000;
      font-size:clamp(2.1rem,6.8vmin,4.1rem);
      line-height:1.02;
      padding:clamp(8px,1.6vmin,12px) clamp(12px,2.2vmin,18px);
      border-radius:clamp(12px,1.8vmin,18px);
      background:rgba(0,0,0,.22);
      border:1px solid rgba(255,255,255,.12);
      box-shadow:inset 0 1px 0 rgba(255,255,255,.06);
      letter-spacing:.6px;
    }
    .reveal-cat{opacity:.75;font-weight:900;text-transform:uppercase;letter-spacing:1px;font-size:clamp(.85rem,2.4vmin,1.05rem)}
    .reveal-catname{
      font-weight:1000;
      font-size:clamp(1.05rem,3.2vmin,1.45rem);
      background:linear-gradient(135deg, var(--accent), var(--accent2));
      -webkit-background-clip:text;
      -webkit-text-fill-color:transparent;
      background-clip:text;
      filter:drop-shadow(0 0 12px rgba(155,89,182,.22));
    }

    /* ANCHOR: JUDGE_UI (po końcu tury: pytanie TAK/NIE pod prezenterem) */
    .judge-wrap{
      width:min(520px,92vw);
      margin:clamp(10px,2vmin,16px) auto 0;
      border-radius:clamp(14px,2vmin,22px);
      border:1px solid rgba(255,255,255,.12);
      background:linear-gradient(135deg, rgba(155,89,182,.16), rgba(233,30,99,.10));
      box-shadow:0 16px 30px rgba(0,0,0,.48);
      padding:clamp(14px,2.4vmin,22px) clamp(16px,2.8vmin,26px);
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      gap:clamp(10px,2vmin,14px);
      user-select:none;
      text-align:center;
    }
    .judge-title{
      font-weight:1000;
      letter-spacing:1px;
      text-transform:uppercase;
      font-size:clamp(1.05rem,3vmin,1.35rem);
      opacity:.95;
    }
    .judge-actions{
      width:100%;
      display:flex;
      gap:clamp(10px,2vmin,16px);
      margin-top:2px;
    }
    .judge-actions button{
      flex:1;
      min-width:0;
    }

</style>
</head>
<body>

  <!-- ANCHOR: DEBUG_HUD (podgląd klas w UI — hover + przypinanie) -->

  <div id="debugHud" class="debug-hud is-hidden" aria-hidden="true">
    <div class="dh-head" id="debugHudHead">
      <div class="dh-head-left">
        <span class="dh-drag" title="Przeciągnij">⠿</span>
        <span class="dh-badge">DEV HUD</span>
      </div>
      <div class="dh-head-right">
        <button type="button" class="dh-stage-btn" id="btnDebugStage" title="STAGE (DEV)">STAGE ▾</button>
        <div class="dh-muted" id="debugHudHint">F9 DEV · F8 COPY · F7 PIN · STAGE (PRZYCISK)</div>
      </div>
    </div>
    <div class="dh-line"><span class="dh-muted">HOVER:</span> <span id="dhHover" class="dh-classes">—</span></div>
    <div class="dh-line"><span class="dh-muted">CLICK:</span> <span id="dhClick" class="dh-classes">—</span></div>
    <div class="dh-tip"><kbd>F9</kbd> DEV <kbd>F8</kbd> COPY <kbd>F7</kbd> PIN <kbd>STAGE</kbd> (BTN)</div>
  </div>

  <!-- ANCHOR: DEV_STAGE_MENU (pod HUDem, nie wpływa na layout) -->
  <div id="devStageMenu" class="is-hidden" aria-hidden="true">
    <div class="dev-stage-menu-title">STAGE</div>
    <div class="dev-stage-menu-row">
      <div class="dev-stage-menu-current" id="devStageValue">IDLE</div>
    </div>
    <select class="dev-stage-select" id="devStageSelect" aria-label="Wybierz etap (dev)"></select>
    <div class="dev-stage-menu-foot">Przycisk STAGE otwiera/zamyka · Zmiana działa tylko w DEV</div>
  </div>

  <!-- ANCHOR: HOME_UI -->
  <div class="overlay is-visible" id="overlayHome" aria-label="Menu główne">
    <div class="home-container" data-dbg2="HOME_CONTAINER">
      <h1 class="home-title">KALAMBURY</h1>

      <!-- ANCHOR: MODE_CARDS_UI -->
      <div class="mode-selection">

        <div class="mode-card classic" data-mode="classic" id="classicCard">
          <div class="mode-header" role="button" tabindex="0">
            <div class="mode-icon">🎭</div>
            <div class="mode-title-wrapper"><div class="mode-title">KLASYCZNA</div></div>
            <div class="mode-arrow">▼</div>
          </div>
          <div class="mode-content">
            <div class="mode-content-inner">
              <div class="mode-details">
                <div class="mode-description">Gracie po kolei — punkt za odgadnięcie hasła.</div>
                <ul class="mode-features">
                  <li>Tryb dla każdej ekipy</li>
                  <li>Szybka rozgrywka</li>
                  <li>2+ graczy</li>
                </ul>
              </div>
              <div class="mode-buttons">
                <button class="mode-btn info" data-mode-info title="Info">i</button>
                <button class="mode-btn play" data-mode-play title="Dalej" aria-label="Dalej"><span class="play-tri" aria-hidden="true"></span></button>
              </div>
            </div>
          </div>
        </div>

        <!-- WIP (placeholder na przyszłe tryby) -->
        <div class="mode-card wip" data-mode="wip" id="wipCard">
          <div class="mode-header" role="button" tabindex="0">
            <div class="mode-icon">⚡</div>
            <div class="mode-title-wrapper">
              <div class="mode-title">WKRÓTCE</div>
              <div class="mode-wip-badge">WIP</div>
            </div>
            <div class="mode-arrow">▼</div>
          </div>
          <div class="mode-content">
            <div class="mode-content-inner">
              <div class="mode-details">
                <div class="mode-description">Dodatkowe tryby Kalambur.</div>
                <ul class="mode-features">
                  <li>Tryb "na czas"</li>
                  <li>Tryb "hasła tematyczne"</li>
                </ul>
              </div>
              <div class="mode-buttons">
                <button class="mode-btn info disabled" title="WIP" disabled>i</button>
                <button class="mode-btn play disabled" title="WIP" aria-label="WIP" disabled><span class="play-tri" aria-hidden="true"></span></button>
              </div>
            </div>
          </div>
        </div>

      </div>

      <!-- ANCHOR: HOME_BOTTOM_BUTTONS -->
      <div class="home-bottom-buttons">
        <button class="home-btn hub-btn" id="btnBackToHub" type="button">← PartyHUB</button>
        <button class="home-btn settings-btn" id="btnGlobalSettings" type="button">⚙️ Ustawienia</button>
      </div>
      <div class="home-version" id="homeVersion"></div>
    </div>
  </div>

  <!-- ANCHOR: MODE_SETTINGS_UI -->
  <div class="overlay" id="overlayModeSettings" aria-label="Ustawienia trybu">
    <div class="settings-container scroll-surface" data-dbg2="MODE_SETTINGS_CONTAINER">
      <h2 class="settings-title">Ustawienia gry</h2>

      <!-- ANCHOR: PLAYERS_STATIC (Gracze zawsze widoczni, bez rozsuwania) -->
      <div class="game-settings" id="playersSettings">
        <h3 class="section-head">
          <span>Gracze</span>
          <span id="playersSummary" class="txt-muted">0/8</span>
          <span id="playersLimit" class="txt-muted is-hidden">Limit 8</span>
        </h3>
        <div id="playersList"></div>
        <div class="setting-actions">
          <button class="btn-new" id="addPlayerBtn" type="button">+ Dodaj gracza</button>
        </div>
      </div>

      <!-- ANCHOR: MODE_SETTINGS_CARDS (kafelki jak w Tajniakach) -->
      <div class="settings-accordion" id="modeSettingsCards">

        <!-- ANCHOR: CARD_ROUND -->
        <div class="setting-card" id="cardRound">
          <div class="setting-head" role="button" tabindex="0" aria-label="Runda">
            <div class="setting-title">Runda</div>
            <div class="setting-sub" id="roundSummary">—</div>
            <div class="setting-arrow">▼</div>
          </div>
          <div class="setting-body">
            <div class="setting-body-inner">
              <div class="setting-row setting-row-range">
                <label for="cfgTurnSeconds">Czas tury:</label>
                <div class="range-wrap" aria-label="Ustaw czas tury">
                  <input id="cfgTurnSeconds" type="range" min="1" max="8" step="1" value="3" />
                  <div class="range-scale range-8" aria-hidden="true">
                    <span>30</span>
                    <span class="scale-off">60</span>
                    <span class="scale-off">90</span>
                    <span>120</span>
                    <span class="scale-off">150</span>
                    <span class="scale-off">165</span>
                    <span>180</span>
                    <span>∞</span>
                  </div>
                </div>
                <div class="range-badge" id="turnSecondsBadge">90s</div>
              </div>

              <div class="setting-row setting-row-range">
                <label for="cfgTargetScore">Limit punktów:</label>
                <div class="range-wrap" aria-label="Ustaw limit punktów">
                  <input id="cfgTargetScore" type="range" min="1" max="8" step="1" value="3" />
                  <div class="range-scale range-8" aria-hidden="true">
                    <span>1</span>
                    <span class="scale-off">2</span>
                    <span class="scale-off">3</span>
                    <span>4</span>
                    <span class="scale-off">5</span>
                    <span class="scale-off">6</span>
                    <span>7</span>
                    <span>∞</span>
                  </div>
                </div>
                <div class="range-badge" id="targetScoreBadge">3</div>
              </div>
            </div>
          </div>
        </div>

        <!-- ANCHOR: CARD_WORDS -->
        <div class="setting-card" id="cardWords">
          <div class="setting-head" role="button" tabindex="0" aria-label="Hasła">
            <div class="setting-title">Hasła</div>
            <div class="setting-sub" id="catsSummary">—</div>
            <div class="setting-arrow">▼</div>
          </div>
          <div class="setting-body">
            <div class="setting-body-inner">
              <div class="small" id="catsCount">0/0</div>
              <div class="cat-grid" id="catsGrid"></div>
              <div class="cat-actions">
                <button class="btn-ghost btn-sm" id="btnCatsAll" type="button">Wszystkie</button>
                <button class="btn-ghost btn-sm" id="btnCatsRandom" type="button">Losowo</button>
                <button class="btn-ghost btn-sm" id="btnCatsNone" type="button">Wyczyść</button>
              </div>
            </div>
          </div>
        </div>

      </div>

      <div class="mode-actions">
        <div class="button-group">
          <button class="btn-back btn-grow-1" id="btnBackToHome" type="button">← Powrót</button>
          <button class="btn-new btn-grow-2 btn-lg" id="btnStartGame" type="button" disabled>Start</button>
        </div>
        <div class="txt-muted mt-10" id="startHint"></div>
      </div>
    </div>
  </div>

  <!-- ANCHOR: GAME_SCREEN (plansza gry — baza wspólna) -->
  <div class="overlay" id="overlayGame" aria-label="Plansza gry — Kalambury">
    <div class="game-screen" data-dbg="GAME_SCREEN">

      <!-- ANCHOR: TOP_BAR (stały) -->
      <div class="top-bar" data-dbg="TOP_BAR">
        <div class="top-bar-inner" data-dbg2="TOP_BAR_INNER">
                    <div class="top-stage-meta is-hidden" id="topStageMeta" data-dbg2="TOP_STAGE_META" aria-label="Info rundy"></div>

          <div class="top-title is-hidden" id="topTitle" aria-label="Etap"></div>

          <button class="gear-btn" id="btnGameSettings" type="button" aria-label="Ustawienia">⚙️</button>
        </div>
      </div>

      <!-- ANCHOR: GAME_HUD (zmienne etapy gry — tu będziemy podmieniać zawartość) -->
      <div class="game-hud" id="gameHud" data-dbg="GAME_HUD">
        <!-- tutaj później: STAGE containers (np. losowanie / hasło / tura / punktowanie) -->
      </div>

      <!-- ANCHOR: BOTTOM_BAR (stały) -->
      <div class="bottom-bar" id="bottomBar" data-dbg="BOTTOM_BAR">
        <!-- tutaj później: przyciski akcji rundy -->
      </div>

    </div>
  </div>

  <!-- ANCHOR: GAME_SETTINGS_OVERLAY_UI (ustawienia na planszy — tylko dźwięk + powrót) -->
  <div class="overlay" id="gameSettingsOverlay" aria-label="Ustawienia w grze — Kalambury">
    <div class="settings-container settings-container--sm scroll-surface" data-dbg2="GAME_SETTINGS_CONTAINER">
      <h2 class="settings-title">Ustawienia</h2>
      <div class="game-settings game-settings--flush">
        <div class="setting-row setting-row--compact">
          <label for="soundToggleGame">Dźwięk:</label>
          <label class="switch" aria-label="Włącz/wyłącz dźwięk (w grze)">
            <input type="checkbox" id="soundToggleGame" />
            <span class="slider"></span>
          </label>
        </div>
      </div>

      <div class="game-settings-actions">
        <button class="btn-new" id="btnGameSettingsClose" type="button">Kontynuuj</button>
        <button class="btn-back" id="btnGameExitToMenu" type="button">← Powrót do menu</button>
      </div>
    </div>
  </div>



  <div class="overlay" id="rulesOverlay" aria-label="Zasady — Kalambury">
    <div class="rules-container scroll-surface" data-dbg2="RULES_CONTAINER">
      <h2 class="rules-title">Zasady — Klasyczna</h2>
      <div class="rules-content">
        <h3>🎯 Cel gry</h3>
        <p>Pokazujecie hasło bez używania go wprost. Reszta zgaduje.</p>
        <h3>🎭 Jak gramy</h3>
        <ul>
          <li>Jedna osoba pokazuje hasło (gesty / mimika / rysowanie — jak ustalicie).</li>
          <li>Gdy ktoś odgadnie — prowadzący przyznaje <span class="highlight">1 punkt</span>.</li>
          <li>Potem kolej przechodzi na następną osobę.</li>
        </ul>
        <h3>🏆 Zwycięstwo</h3>
        <p>Wygrywa osoba z <span class="highlight">największą liczbą punktów</span> (albo gracie do ustalonego limitu).</p>
      </div>
      <button class="btn-new" id="btnRulesOk" type="button">Rozumiem</button>
    </div>
  </div>

  <!-- ANCHOR: GLOBAL_SETTINGS_UI -->
  <div class="overlay" id="globalSettingsOverlay" aria-label="Ustawienia — Kalambury">
    <div class="settings-container settings-container--sm scroll-surface">
      <h2 class="settings-title">Ustawienia</h2>
      <div class="game-settings game-settings--flush">

        <!-- ANCHOR: SETTINGS_SOUND -->
        <div class="setting-row setting-row--compact">
          <label for="soundToggle">Dźwięk:</label>
          <label class="switch" aria-label="Włącz/wyłącz dźwięk">
            <input type="checkbox" id="soundToggle" />
            <span class="slider"></span>
          </label>
        </div>

        <!-- ANCHOR: SETTINGS_MOTION -->
        <div class="setting-row setting-row--compact">
          <label for="motionToggle">Animacje:</label>
          <label class="switch" aria-label="Włącz/wyłącz animacje">
            <input type="checkbox" id="motionToggle" />
            <span class="slider"></span>
          </label>
        </div>

        <!-- ANCHOR: SETTINGS_CLEAR_DATA -->
        <div class="setting-row setting-row--compact">
          <label>Dane gry:</label>
          <button class="btn-reset btn-sm" id="btnClearData" type="button">Wyczyść</button>
        </div>

        <div class="setting-row setting-row--last">
          <label>Wersja:</label>
          <span id="txtVersion" class="txt-muted">—</span>
        </div>
      </div>
      <button class="btn-new btn-close" id="btnGlobalSettingsClose" type="button">Zamknij</button>
    </div>
  </div>

  <!-- ANCHOR: CONFIRM_UI (spójny popup PartyHUB) -->
  <div class="overlay" id="confirmOverlay" aria-label="Potwierdzenie">
    <div class="settings-container settings-container--sm scroll-surface" data-dbg2="CONFIRM_CONTAINER">
      <h2 class="settings-title" id="confirmTitle">Potwierdź</h2>
      <p id="confirmMessage" class="confirm-msg"></p>
      <div class="button-group">
        <button class="btn-ghost" id="confirmCancel" type="button">Anuluj</button>
        <button class="btn-reset" id="confirmOk" type="button">OK</button>
      </div>
    </div>
  </div>

  <!-- ANCHOR: EMOJI_PICKER_OVERLAY (1:1 z 5 Sekund) -->
  <div class="overlay" id="emojiPickerOverlay">
    <div class="settings-container settings-container--sm" data-dbg2="EMOJI_PICKER_CONTAINER">
      <h2 class="settings-title" id="emojiPickerTitle">Nowy gracz</h2>
      <div class="card-block">
        <label class="emoji-name-label" for="emojiPickerNameInput">Nazwa gracza</label>
        <input type="text" id="emojiPickerNameInput" class="emoji-name-input" placeholder="Min. 3 znaki..." minlength="3" />
        <div id="emojiPickerError" class="txt-muted mt-8 text-center is-hidden"></div>
      </div>
      <div class="card-block emoji-picker-avatars">
        <div class="small">Wybierz avatar</div>
        <div class="emoji-tabs" id="emojiTabs">
          <button type="button" class="emoji-tab selected" id="emojiTabPeople" data-emoji-cat="people">Ludzie</button>
          <button type="button" class="emoji-tab" id="emojiTabAnimals" data-emoji-cat="animals">Zwierzęta</button>
          <button type="button" class="emoji-tab" id="emojiTabOther" data-emoji-cat="other">Inne</button>
        </div>
        <div class="emoji-grid scroll-surface" id="emojiGrid"></div>
      </div>
      <div class="emoji-picker-actions">
        <button class="btn-ghost" id="btnEmojiCancel" type="button">Anuluj</button>
        <button class="btn-primary" id="btnConfirmEmoji" type="button" disabled>Gotowe</button>
      </div>
    </div>
  </div>

  <!-- ANCHOR: TWEMOJI_TEST (CDN) -->
  <script defer src="https://cdn.jsdelivr.net/npm/twemoji@14.0.2/dist/twemoji.min.js" crossorigin="anonymous"></script>

  <script>
    /*
      PartyHUB — Kalambury
      Etap 1: Menu główne + wejście do ustawień trybu + zasady.
      Etap 2: Ustawienia w menu głównym + ustawienia globalne.
      Etap 3: Ustawienia trybu — moduł graczy (1:1 z 5 Sekund: overlay + avatary).

      Instrukcja #4 (czystość kodu): brak duplikatów i martwych elementów.
    */

    // ANCHOR: VERSION
    const GAME_VERSION = '1.0.1';

    // ANCHOR: CFG_CONSTANTS
    const TURN_STEPS = [30,60,90,120,150,165,180,0]; // 0 => no limit
    const SCORE_STEPS = [1,2,3,4,5,6,7,0]; // 0 => no limit

    // ANCHOR: STATE_MACHINE
    const state = {
      selectedMode: null,
      cfg: { classic: { turnSeconds: 90, targetScore: 3, categories: [] } },
      settings: { soundOn: true, motionOn: true }, // ANCHOR: SETTINGS_STATE

      // ANCHOR: GAME_STAGE_STATE (etap planszy — głównie do dev-skipowania etapów)
      game: { stage:'idle', rolling:false, orderIds:[], orderPos:{}, focusId:null, layoutIds:[], forceDeck:false, presenterIdx:0, stage2GridOpen:false }
    };

    // ANCHOR: PLAYERS_STATE (musi być przed jakimkolwiek użyciem — TDZ fix)
let players = [];              // [{id,name,emoji,score}]
let draftPlayer = null;        // roboczy obiekt w pickerze
let emojiPickerForId = null;   // id gracza edytowanego (null = nowy)
let tempSelectedEmoji = null;  // emoji zaznaczone w pickerze

// ANCHOR: UNIQUE_PLAYER_NAMES
const normName = (s) => String(s||'').trim().replace(/\s+/g,' ').toLowerCase();

    // ANCHOR: DOM_REFS
    const $ = (id) => document.getElementById(id);
    // ANCHOR: GAME_OVERLAY_REFS
    // Na razie: tylko pusty overlay #overlayGame (bez elementów wewnętrznych).


    // ANCHOR: TWEMOJI (TEST)
    function applyTwemoji(root){
      if(!root || !window.twemoji) return;
      window.twemoji.parse(root, { folder:'svg', ext:'.svg' });
    }

    // ANCHOR: FIT_TEXT (skalowanie nazw graczy do pola — długie nazwy nie wychodzą poza kafel)
    let __fitT = 0;

    function fitTextToBox(el, minPx=12){
      if(!el) return;
      // reset do CSS (responsywne clamp)
      el.style.fontSize = '';
      const cw = el.clientWidth;
      if(cw <= 0) return;
      const sw = el.scrollWidth;
      if(sw <= cw) return;

      const base = parseFloat(getComputedStyle(el).fontSize) || 16;
      const ratio = cw / sw;
      const target = Math.max(minPx, Math.floor(base * ratio * 0.98));
      if(target < base) el.style.fontSize = target + 'px';
    }

    function fitAllPlayerNames(){
      // Po wycięciu planszy gry zostawiamy tylko dopasowanie nazw w menu/ustawieniach.
      document.querySelectorAll('.player-name-display').forEach(el=>fitTextToBox(el, 12));
    }

    function scheduleFitNames(){
      clearTimeout(__fitT);
      __fitT = setTimeout(fitAllPlayerNames, 60);
    }

    window.addEventListener('resize', scheduleFitNames);

    // ANCHOR: TWEMOJI_READY (bez przerabiania całego UI — tylko avatary)
    function whenTwemojiReady(cb){
      if(window.twemoji) return cb();
      let tries = 0;
      const t = setInterval(()=>{
        tries++;
        if(window.twemoji){ clearInterval(t); cb(); }
        else if(tries >= 80) clearInterval(t); // ~4s
      }, 50);
    }

    // ANCHOR: DOM_CACHE
    const overlayHome = $('overlayHome');
    const overlayModeSettings = $('overlayModeSettings');
    const overlayGame = $('overlayGame');

    // ANCHOR: INLINE_FREE_REFS
    const btnRulesOk = $('btnRulesOk');
    const btnGlobalSettingsClose = $('btnGlobalSettingsClose');
    const btnEmojiCancel = $('btnEmojiCancel');
    const emojiTabs = $('emojiTabs');
    const emojiPickerNameInput = $('emojiPickerNameInput');

    const btnBackToHome = $('btnBackToHome');
    const btnStartGame = $('btnStartGame');

    const btnBackToHub = $('btnBackToHub');
    const btnGlobalSettings = $('btnGlobalSettings');
    const btnGameSettings = $('btnGameSettings');
    const devStageSelect = $('devStageSelect');
const devStageValue = $('devStageValue');
// (legacy) stage-pill w TOP BAR usunięty — STAGE jest tylko w DEV menu (pod HUD)
    const topTitle = $('topTitle');
    const gameHud = $('gameHud');
    const bottomBar = $('bottomBar');

    // ANCHOR: GAME_SETTINGS_REFS (ustawienia na planszy)
    const soundToggleGame = $('soundToggleGame');
    const btnGameSettingsClose = $('btnGameSettingsClose');
    const btnGameExitToMenu = $('btnGameExitToMenu');

    // ANCHOR: GAME_SETTINGS_REFS_REMOVED (plansza gry wycięta)



    // ANCHOR: GLOBAL_SETTINGS_REFS
    const txtVersion = $('txtVersion');
    const homeVersion = $('homeVersion');
    const soundToggle = $('soundToggle');
    const motionToggle = $('motionToggle');
    const btnClearData = $('btnClearData');

    // ANCHOR: CONFIRM_UI_REFS
    const confirmTitle = $('confirmTitle');
    const confirmMessage = $('confirmMessage');
    const confirmCancel = $('confirmCancel');
    const confirmOk = $('confirmOk');
    let confirmCb = null;

    // ANCHOR: POPUPS_API
    function showO(id){ const el=$(id); if(el) el.classList.add('is-visible'); }
    function hideO(id){ const el=$(id); if(el) el.classList.remove('is-visible'); }

    // ANCHOR: CONFIRM_CLOSE (czyści callback przy każdym zamknięciu)
    function closeConfirm(){ confirmCb = null; hideO('confirmOverlay'); }

    // ANCHOR: MODE_SETTINGS_REFS
    const cfgTurnSeconds = $('cfgTurnSeconds');
    const turnSecondsBadge = $('turnSecondsBadge');
    const cfgTargetScore = $('cfgTargetScore');
    const targetScoreBadge = $('targetScoreBadge');
    const addPlayerBtn = $('addPlayerBtn');
    const playersSummary = $('playersSummary');
    const playersLimit = $('playersLimit');
    const roundSummary = $('roundSummary');

    // ANCHOR: CATEGORIES_REFS
    const catsGrid = $('catsGrid');
    const catsSummary = $('catsSummary');
    const catsCount = $('catsCount');
    const btnCatsAll = $('btnCatsAll');
    const btnCatsRandom = $('btnCatsRandom');
    const btnCatsNone = $('btnCatsNone');

    // ANCHOR: SETTINGS_CARDS_REFS
    const modeSettingsCards = $('modeSettingsCards');

    // ANCHOR: OVERLAY_NAV

    // ANCHOR: OVERLAY_NAV
    function showOverlay(el){
      // trzymamy porządek: zamknij popupy zanim przełączysz ekran
      closeConfirm();
      hideGameSettings();
      hideGlobalSettings();
      hideO('rulesOverlay');

      // Jeśli picker jest otwarty, zamykamy go "bezpiecznie" (czyści draft i stan)
      const ep = $('emojiPickerOverlay');
      if(ep && ep.classList.contains('is-visible')) cancelEmojiPicker();

      // Ukryj WSZYSTKIE overlaye (menu / ustawienia trybu / popupy)
      document.querySelectorAll('.overlay').forEach(o=>o.classList.remove('is-visible'));

      // Pokaż docelowy ekran
      if(el) el.classList.add('is-visible');
    }


    // ANCHOR: OVERLAY_CLOSE (Esc + klik poza okno)
    const isVisible = (id) => { const el=$(id); return !!(el && el.classList.contains('is-visible')); };

    function closeTopOverlay(){
      if(isVisible('confirmOverlay')) return closeConfirm();
      if(isVisible('emojiPickerOverlay')) return cancelEmojiPicker();
      if(isVisible('gameSettingsOverlay')) return hideGameSettings();
      if(isVisible('globalSettingsOverlay')) return hideGlobalSettings();
      if(isVisible('rulesOverlay')) return hideO('rulesOverlay');
      if(overlayModeSettings && overlayModeSettings.classList.contains('is-visible')) return backToHome();
    }



    window.addEventListener('keydown', (e)=>{ if(e.key==='Escape') closeTopOverlay(); });

    // ANCHOR: DEV_KEYS_MAP (F9 dev mode, F8 copy, F7 PIN; STAGE z przycisku)
    (function(){
      const isTypingTarget = (el)=>{
        if(!el) return false;
        const tag = String(el.tagName||'').toLowerCase();
        if(tag === 'input' || tag === 'textarea' || tag === 'select') return true;
        return !!el.isContentEditable;
      };

      const hudEl = ()=> document.getElementById('debugHud');
      const setHudVisible = (on)=>{
        const el = hudEl();
        if(!el) return;
        el.classList.toggle('is-hidden', !on);
        el.setAttribute('aria-hidden', on ? 'false' : 'true');
      };

      const toggleDevMode = ()=>{
        const b = document.body;
        if(!b) return;
        const on = !b.classList.contains('design-debug');
        b.classList.toggle('design-debug', on);
        // przy wyłączaniu dev — zamknij menu STAGE
        if(!on && typeof window.closeDevStageMenu === 'function') window.closeDevStageMenu();
        setHudVisible(on);
      };

      const toastCopy = ()=>{
        const el = hudEl();
        if(!el) return;
        el.classList.add('copied');
        try{ clearTimeout(el.__copyT); }catch(_e){}
        el.__copyT = setTimeout(()=>el.classList.remove('copied'), 850);
      };

      const copyHud = async ()=>{
        const el = hudEl();
        if(!el) return;
        const txt = String(el.innerText || el.textContent || '').trim();
        if(!txt) return;
        try{
          await navigator.clipboard.writeText(txt);
          toastCopy();
        }catch(_e){
          // fallback
          const ta = document.createElement('textarea');
          ta.value = txt;
          ta.setAttribute('readonly','');
          ta.style.position = 'fixed';
          ta.style.opacity = '0';
          document.body.appendChild(ta);
          ta.select();
          try{ document.execCommand('copy'); toastCopy(); }catch(__e){}
          ta.remove();
        }
      };

      const togglePin = ()=>{
        const el = hudEl();
        if(!el) return;
        // jeśli istnieje inna implementacja PIN — użyj jej
        if(typeof window.toggleDebugHudPin === 'function'){
          window.toggleDebugHudPin();
          return;
        }
        const pinned = (el.dataset.pinned === '1');
        el.dataset.pinned = pinned ? '0' : '1';
        el.classList.toggle('is-pinned', !pinned);
      };

      const toggleStageMenu = ()=>{
        const b = document.body;
        if(!b || !b.classList.contains('design-debug')) return;
        if(typeof window.toggleDevStageMenu === 'function') return window.toggleDevStageMenu();
        const m = document.getElementById('devStageMenu');
        if(!m) return;
        m.classList.toggle('is-hidden');
      };

      window.addEventListener('keydown', (e)=>{
        const code = e.code || '';

        // nie kradnij klawiszy gdy user pisze w polu (poza naszymi F6–F9)
        if(isTypingTarget(document.activeElement) && !['F7','F8','F9'].includes(code)) return;

        if(code === 'F9'){
          e.preventDefault();
          if(typeof e.stopImmediatePropagation === 'function') e.stopImmediatePropagation();
          e.stopPropagation();
          toggleDevMode();
          return;
        }

        if(!document.body.classList.contains('design-debug')) return;

        if(code === 'F8'){
          e.preventDefault();
          if(typeof e.stopImmediatePropagation === 'function') e.stopImmediatePropagation();
          e.stopPropagation();
          copyHud();
          return;
        }

        if(code === 'F7'){
          e.preventDefault();
          if(typeof e.stopImmediatePropagation === 'function') e.stopImmediatePropagation();
          e.stopPropagation();
          togglePin();
          return;
        }
      }, true);
    })();

    ['rulesOverlay','gameSettingsOverlay','globalSettingsOverlay','confirmOverlay','emojiPickerOverlay'].forEach(id=>{
      const el = $(id);
      if(!el) return;
      el.addEventListener('click', (e)=>{
        if(e.target !== el) return;
        if(id === 'emojiPickerOverlay') return cancelEmojiPicker();
        if(id === 'confirmOverlay') return closeConfirm();
        if(id === 'gameSettingsOverlay') return hideGameSettings();
        if(id === 'globalSettingsOverlay') return hideGlobalSettings();
        hideO(id);
      });
    });

    // ANCHOR: TOP_BAR_META_SYNC (Stage 2 info w TOP_BAR)
    function syncTopBarMeta(){
      const host = $('topStageMeta');
      if(!host) return;
      const isS2 = !!(state && state.game && state.game.stage === 'stage2');
      host.classList.toggle('is-hidden', !isS2);
      if(!isS2){ host.innerHTML = ''; return; }
      host.innerHTML = (state && state.game && state.game.topBarMetaHtml) ? state.game.topBarMetaHtml : '';
    }

    // ANCHOR: DEV_STAGE_SWITCHER_LOGIC (dropdown w TOP_BAR — tylko do dev)
// Lista etapów DEV = tylko te, które realnie istnieją w kodzie.
const DEV_STAGE_LIST = [
  { id:'idle',   label:'IDLE (pusty HUD)' },
  { id:'stage1', label:'STAGE 1 - Losowanie' },
  { id:'stage2', label:'STAGE 2 - Start rundy' }
];

    // ANCHOR: DEV_STAGE_MENU_API (menu pod debugHud)
    function getDevStageMenuEl(){ return document.getElementById('devStageMenu'); }
    function isDevStageMenuOpen(){ const m = getDevStageMenuEl(); return !!(m && !m.classList.contains('is-hidden')); }

    function positionDevStageMenu(){
      const m = getDevStageMenuEl();
      const hud = document.getElementById('debugHud');
      if(!m || !hud) return;

      const gap = 10;
      const r = hud.getBoundingClientRect();

      // tymczasowo pokazujemy do pomiaru (może być pierwszy raz)
      const wasHidden = m.classList.contains('is-hidden');
      if(wasHidden) m.classList.remove('is-hidden');

      const mw = m.offsetWidth || 0;
      const mh = m.offsetHeight || 0;
      const vw = window.innerWidth || 0;
      const vh = window.innerHeight || 0;

      let left = r.left;
      let top = r.bottom + gap;

      // trzymamy w viewport
      if(left + mw > vw - 10) left = Math.max(10, vw - mw - 10);
      if(top + mh > vh - 10) top = Math.max(10, r.top - mh - gap);

      m.style.left = `${Math.round(left)}px`;
      m.style.top  = `${Math.round(top)}px`;

      if(wasHidden) m.classList.add('is-hidden');
    }

    let __devStageMenuRAF = 0;
    function startFollowDevStageMenu(){
      cancelAnimationFrame(__devStageMenuRAF);
      const tick = ()=>{
        if(!isDevStageMenuOpen()) return;
        positionDevStageMenu();
        __devStageMenuRAF = requestAnimationFrame(tick);
      };
      __devStageMenuRAF = requestAnimationFrame(tick);
    }

    function openDevStageMenu(){
      if(!document.body.classList.contains('design-debug')) return;
      const m = getDevStageMenuEl();
      if(!m) return;
      m.classList.remove('is-hidden');
      m.setAttribute('aria-hidden','false');
      positionDevStageMenu();
      startFollowDevStageMenu();
      const sel = document.getElementById('devStageSelect');
      if(sel){
        try{ sel.focus({ preventScroll:true }); }catch(_e){ try{ sel.focus(); }catch(__e){} }
      }
    }

    function closeDevStageMenu(){
      const m = getDevStageMenuEl();
      if(!m) return;
      m.classList.add('is-hidden');
      m.setAttribute('aria-hidden','true');
    }

    function toggleDevStageMenu(){
      if(isDevStageMenuOpen()) closeDevStageMenu();
      else openDevStageMenu();
    }

    // expose for dev-keys IIFE
    window.openDevStageMenu = openDevStageMenu;
    window.closeDevStageMenu = closeDevStageMenu;
    window.toggleDevStageMenu = toggleDevStageMenu;

    // klik poza menu zamyka (nie koliduje z overlayami)
    document.addEventListener('pointerdown', (e)=>{
      if(!document.body.classList.contains('design-debug')) return;
      const m = getDevStageMenuEl();
      if(!m || m.classList.contains('is-hidden')) return;
      const hud = document.getElementById('debugHud');
      if(m.contains(e.target) || (hud && hud.contains(e.target))) return;
      closeDevStageMenu();
    }, true);

    window.addEventListener('resize', ()=>{ if(isDevStageMenuOpen()) positionDevStageMenu(); });

    function setGameStage(stageId, { persist=true }={}){
      const meta = DEV_STAGE_LIST.find(s=>s.id===stageId) || DEV_STAGE_LIST[0];
      const id = meta ? meta.id : 'idle';

      state.game.stage = id;
      if(id === 'stage2') state.game.stage2GridOpen = false;
      if(gameHud) gameHud.setAttribute('data-stage', id);
      if(devStageSelect) devStageSelect.value = id;
      if(devStageValue) devStageValue.textContent = String((meta && meta.label) ? meta.label : id).toUpperCase();

      // TOP BAR title (w normalnym trybie): LOSOWANIE / PREZENTUJE
      if(topTitle){
        const t = (id === 'stage1') ? 'LOSOWANIE' : '';
        topTitle.textContent = t;
        topTitle.classList.toggle('is-hidden', !t);
      }

      if(persist){ try{ sessionStorage.setItem('partyhub_kalambury_dev_stage', id); }catch(_e){} }

      // po zmianie etapu: odśwież HUD
      if(typeof renderGameStage === 'function') renderGameStage();

      // TOP BAR meta (Stage 2)
      syncTopBarMeta();
    }

    function initDevStageSelect(){
      if(!devStageSelect) return;
      devStageSelect.innerHTML = DEV_STAGE_LIST.map(s=>`<option value="${s.id}">${s.label}</option>`).join('');

      // restore (dev)
      let saved = null;
      try{ saved = sessionStorage.getItem('partyhub_kalambury_dev_stage'); }catch(_e){}
      setGameStage(saved || state.game.stage || 'idle', { persist:false });

      if(devStageSelect.dataset.bound === '1') return;

      devStageSelect.addEventListener('change', (e)=>{
        setGameStage(e.target.value);
        if(typeof closeDevStageMenu === 'function') closeDevStageMenu();
      });
devStageSelect.dataset.bound = '1';
    }

    // ANCHOR: DEV_STAGE_BOOT (wypełnij select od razu — menu inaczej jest puste)
    initDevStageSelect();
    // ANCHOR: DEV_STAGE_BTN_BIND (klik na STAGE w DEV HUD)
    (function(){
      const btn = document.getElementById('btnDebugStage');
      if(!btn || btn.dataset.bound === '1') return;
      btn.dataset.bound = '1';
      btn.addEventListener('click', (e)=>{
        e.preventDefault();
        if(!document.body.classList.contains('design-debug')) return;
        if(typeof window.toggleDevStageMenu === 'function') window.toggleDevStageMenu();
      });
    })();


    // ANCHOR: DEBUG_HUD_LOGIC (HOVER/CLICK + DRAG + PIN)
    (function(){
      const hud = document.getElementById('debugHud');
      const hudHead = document.getElementById('debugHudHead');
      const outHover = document.getElementById('dhHover');
      const outClick = document.getElementById('dhClick');
      const menu = document.getElementById('devStageMenu');

      if(!hud || !hudHead) return;

      const isDev = ()=> document.body && document.body.classList.contains('design-debug');
      const isHudVisible = ()=> !hud.classList.contains('is-hidden');

      const describeEl = (el)=>{
        if(!el || el === document.documentElement || el === document.body) return '—';
        const tag = String(el.tagName||'').toLowerCase();
        const id = el.id ? `#${el.id}` : '';
        const cls = el.classList && el.classList.length
          ? '.' + Array.from(el.classList).slice(0,6).join('.')
          : '';
        const dbg = (el.dataset && el.dataset.dbg) ? ` [${el.dataset.dbg}]` : '';
        const dbg2 = (el.dataset && el.dataset.dbg2) ? ` [${el.dataset.dbg2}]` : '';
        return `${tag}${id}${cls}${dbg}${dbg2}`.trim();
      };

      const setLine = (node, txt)=>{
        if(!node) return;
        node.textContent = txt || '—';
      };

      // CLICK selection + PIN
      let pinned = false;
      let clickedEl = null;

      const applyPinUi = ()=>{
        hud.dataset.pinned = pinned ? '1' : '0';
        hud.classList.toggle('is-pinned', pinned);
      };

      const setClicked = (el)=>{
        clickedEl = el || null;
        setLine(outClick, describeEl(clickedEl));
      };

      // Expose API for F7 handler (key-map ma hook)
      window.toggleDebugHudPin = ()=>{
        pinned = !pinned;
        applyPinUi();
        // jeżeli pin włączony bez wcześniejszego click — przypnij ostatni hover
        if(pinned && !clickedEl){
          try{ setClicked(window.__dhLastHoverEl || null); }catch(_e){}
        }
      };

      // HOVER
      const setHover = (el)=>{
        window.__dhLastHoverEl = el || null;
        setLine(outHover, describeEl(el));
      };

      const shouldIgnoreTarget = (t)=>{
        if(!t || !(t instanceof Element)) return true;
        if(hud.contains(t)) return true;
        if(menu && !menu.classList.contains('is-hidden') && menu.contains(t)) return true;
        return false;
      };

      document.addEventListener('pointermove', (e)=>{
        if(!isDev() || !isHudVisible()) return;
        const t = e.target;
        if(shouldIgnoreTarget(t)) return;
        setHover(t);
      }, true);

      document.addEventListener('pointerdown', (e)=>{
        if(!isDev() || !isHudVisible()) return;
        const t = e.target;
        if(shouldIgnoreTarget(t)) return;
        if(pinned) return; // PIN blokuje zmianę CLICK
        setClicked(t);
      }, true);

      // DRAG (HUD)
      const clamp = (v, a, b)=> Math.max(a, Math.min(b, v));
      const loadPos = ()=>{
        try{
          const raw = localStorage.getItem('partyhub_kalambury_hud_pos');
          if(!raw) return;
          const pos = JSON.parse(raw);
          if(!pos || typeof pos !== 'object') return;
          if(Number.isFinite(pos.left) && Number.isFinite(pos.top)){
            hud.style.left = `${pos.left}px`;
            hud.style.top  = `${pos.top}px`;
            hud.style.bottom = 'auto';
          }
        }catch(_e){}
      };
      const savePos = ()=>{
        try{
          const r = hud.getBoundingClientRect();
          localStorage.setItem('partyhub_kalambury_hud_pos', JSON.stringify({ left: Math.round(r.left), top: Math.round(r.top) }));
        }catch(_e){}
      };

      loadPos();

      let drag = null;
      hudHead.addEventListener('pointerdown', (e)=>{
        if(!isDev()) return;
        // pozwól kliknąć przycisk STAGE bez drag
        const btn = e.target && e.target.closest ? e.target.closest('#btnDebugStage') : null;
        if(btn) return;

        e.preventDefault();
        hud.classList.add('dragging');

        const r = hud.getBoundingClientRect();
        drag = {
          pid: e.pointerId,
          startX: e.clientX,
          startY: e.clientY,
          startL: r.left,
          startT: r.top,
        };
        try{ hudHead.setPointerCapture(e.pointerId); }catch(_e){}
      });

      hudHead.addEventListener('pointermove', (e)=>{
        if(!drag || e.pointerId !== drag.pid) return;
        const dx = e.clientX - drag.startX;
        const dy = e.clientY - drag.startY;
        const vw = window.innerWidth || 0;
        const vh = window.innerHeight || 0;
        const r = hud.getBoundingClientRect();
        const w = r.width || 0;
        const h = r.height || 0;

        const left = clamp(drag.startL + dx, 8, Math.max(8, vw - w - 8));
        const top  = clamp(drag.startT + dy, 8, Math.max(8, vh - h - 8));

        hud.style.left = `${Math.round(left)}px`;
        hud.style.top  = `${Math.round(top)}px`;
        hud.style.bottom = 'auto';
      });

      const endDrag = (e)=>{
        if(!drag || (e && e.pointerId !== drag.pid)) return;
        drag = null;
        hud.classList.remove('dragging');
        savePos();
      };
      hudHead.addEventListener('pointerup', endDrag);
      hudHead.addEventListener('pointercancel', endDrag);

      // startowy stan tekstów
      setLine(outHover, '—');
      setLine(outClick, '—');
      applyPinUi();
    })();


    // ANCHOR: START_STAGE1_ENSURE (hotfix: po START zawsze widać Stage 1)
    (function(){
      const btn = document.getElementById('btnStartGame');
      if(!btn || btn.dataset.boundStageFix === '1') return;
      btn.dataset.boundStageFix = '1';

      btn.addEventListener('click', ()=>{
        // po ewentualnej istniejącej logice: dopnij Stage 1 jeśli HUD pusty / stage = idle
        setTimeout(()=>{
          try{
            // ensure overlay game visible
            if(typeof showOverlay === 'function' && typeof overlayGame !== 'undefined' && overlayGame){
              if(!overlayGame.classList.contains('is-visible')) showOverlay(overlayGame);
            }

            const cur = (state && state.game && state.game.stage) ? String(state.game.stage) : 'idle';
            if(cur === 'idle' || !cur){
              try{ reshuffleStage1Layout(); }catch(_e){}
              if(state && state.game){
                state.game.rolling = false;
                state.game.orderIds = [];
                state.game.orderPos = {};
                state.game.focusId = null;
                state.game.presenterIdx = 0;
              }
              if(typeof setGameStage === 'function') setGameStage('stage1', { persist:false });
            }else{
              if(typeof renderGameStage === 'function') renderGameStage();
            }
          }catch(e){ console.error('Start Stage1 ensure failed', e); }
        }, 0);
      }, true);
    })();

    // ANCHOR: GAME_SETTINGS_UI (na planszy — osobne od globalnych)
    function showGameSettings(){
      if(soundToggleGame) soundToggleGame.checked = !!state.settings.soundOn;
      showO('gameSettingsOverlay');
    }

    function hideGameSettings(){
      hideO('gameSettingsOverlay');
    }

    // ANCHOR: GLOBAL_SETTINGS_UI
    function showGlobalSettings(){
      applySettingsToUI();
      const el = $('globalSettingsOverlay');
      if(!el){ console.error('Brak #globalSettingsOverlay w DOM'); return; }
      if(el.parentElement !== document.body) document.body.appendChild(el);
      el.classList.add('is-visible');
    }

    function hideGlobalSettings(){
      const el = $('globalSettingsOverlay');
      if(!el) return;
      el.classList.remove('is-visible');
      // inline clean (na wypadek wcześniejszych eksperymentów)
      el.style.display='';
      el.style.position='';
      el.style.inset='';
      el.style.zIndex='';
      el.style.alignItems='';
      el.style.justifyContent='';
    }

    // ANCHOR: SETTINGS_PERSIST
    let motionWasSaved = false;

    function saveSettings(){ try{ localStorage.setItem('partyhub_kalambury_settings', JSON.stringify(state.settings)); }catch(_e){} }

    function loadSettings(){
      try{
        const raw = localStorage.getItem('partyhub_kalambury_settings');
        if(!raw) return;
        const s = JSON.parse(raw);
        if(!s || typeof s !== 'object') return;
        if(typeof s.soundOn === 'boolean') state.settings.soundOn = s.soundOn;
        if(typeof s.motionOn === 'boolean'){ state.settings.motionOn = s.motionOn; motionWasSaved = true; }
      }catch(_e){}
    }

    function applyMotionSetting(){
      const b = document.body;
      if(!b) return;
      if(state.settings.motionOn){ b.classList.add('motion-on'); b.classList.remove('motion-off'); }
      else { b.classList.add('motion-off'); b.classList.remove('motion-on'); }
    }

    function applySettingsToUI(){
      if(soundToggle) soundToggle.checked = !!state.settings.soundOn;
      if(soundToggleGame) soundToggleGame.checked = !!state.settings.soundOn;
      if(motionToggle) motionToggle.checked = !!state.settings.motionOn;
      applyMotionSetting();
    }

    // ANCHOR: SETTINGS_SETTERS (żeby spinać wiele toggle'i do jednego stanu)
    function setSoundOn(v){
      state.settings.soundOn = !!v;
      if(soundToggle) soundToggle.checked = state.settings.soundOn;
      if(soundToggleGame) soundToggleGame.checked = state.settings.soundOn;
      saveSettings();
    }

    function setMotionOn(v){
      state.settings.motionOn = !!v;
      if(motionToggle) motionToggle.checked = state.settings.motionOn;
      applyMotionSetting();
      saveSettings();
    }

    // ANCHOR: CONFIRM_UI
    function openConfirm({ title, message, okText='OK', cancelText='Anuluj', okClass='btn-reset', onConfirm }){
      if(confirmTitle) confirmTitle.textContent = title || 'Potwierdź';
      if(confirmMessage) confirmMessage.textContent = message || '';
      if(confirmOk) confirmOk.textContent = okText;
      if(confirmCancel) confirmCancel.textContent = cancelText;

      // ANCHOR: CONFIRM_OK_CLASS
      if(confirmOk){
        confirmOk.classList.remove('btn-reset','btn-ghost','btn-new','btn-primary','btn-back');
        String(okClass||'').split(/\s+/).filter(Boolean).forEach(c=>confirmOk.classList.add(c));
      }

      confirmCb = typeof onConfirm === 'function' ? onConfirm : null;
      showO('confirmOverlay');
    }

    // ANCHOR: CLEAR_DATA_IMPL
    function wipeKalamburyStorage(){
      let removed = 0;
      try{
        const keys = [];
        for(let i=0;i<localStorage.length;i++){
          const k = localStorage.key(i);
          if(k && k.startsWith('partyhub_kalambury_')) keys.push(k);
        }
        keys.forEach(k=>{ try{ localStorage.removeItem(k); removed++; }catch(_e){} });
      }catch(_e){}
      return removed;
    }

    function resetKalamburyState(){
      state.selectedMode = null;
      state.cfg.classic = { turnSeconds: 90, targetScore: 3, categories: [] };

      const sysReduce = !!(window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches);
      state.settings = { soundOn: true, motionOn: !sysReduce };
      motionWasSaved = false;

      players = [];
      draftPlayer = null;
      emojiPickerForId = null;
      tempSelectedEmoji = null;

      applySettingsToUI();
      applyCfgToUI();
      renderCategories();
      renderPlayers();
      validateStart();
      showOverlay(overlayHome);
    }

    function clearGameData(){
      const removed = wipeKalamburyStorage();
      resetKalamburyState();
      console.log('Kalambury: cleared', { removed });
    }

    // ANCHOR: MODE_SELECTION_LOGIC
    function toggleModeCard(card){
      const wasOpen = card.classList.contains('open');
      document.querySelectorAll('.mode-card').forEach(c => c.classList.remove('open'));
      if(!wasOpen) card.classList.add('open');
    }
    function selectMode(modeId){ if(modeId !== 'wip') state.selectedMode = modeId; }

    // ANCHOR: MODE_SETTINGS_LOGIC

    // ANCHOR: WORDS_BANK_REMOVED (silnik haseł zrobimy od zera)



    const CATEGORY_LIST = [
      { id:'classic', label:'Klasyczne' },
      { id:'movies', label:'Filmy i seriale' },
      { id:'music', label:'Muzyka' },
      { id:'sports', label:'Sport' },
      { id:'jobs', label:'Zawody' },
      { id:'food', label:'Jedzenie' },
      { id:'places', label:'Miejsca' },
      { id:'animals', label:'Zwierzęta' },
      { id:'random', label:'Przysłowia' },
      { id:'dev', label:'DEV' } // ANCHOR: CATEGORY_DEV
    ];

    function validateCfg(){
      const cfg = state.cfg.classic;
      const tOk = (cfg.turnSeconds === 0) || TURN_STEPS.includes(cfg.turnSeconds);
      const sOk = SCORE_STEPS.includes(cfg.targetScore);
      const cOk = Array.isArray(cfg.categories) && cfg.categories.length >= 1;
      return tOk && sOk && cOk;
    }

    function syncTurnSecondsBadge(){
      if(!turnSecondsBadge) return;
      const v = state.cfg.classic.turnSeconds;
      turnSecondsBadge.textContent = (v === 0) ? '∞' : `${v}s`;
    }

    function syncTargetScoreBadge(){
      if(!targetScoreBadge) return;
      const v = state.cfg.classic.targetScore;
      targetScoreBadge.textContent = (v === 0) ? '∞' : String(v);
    }

    function saveCfg(){ try{ localStorage.setItem('partyhub_kalambury_cfg_classic', JSON.stringify(state.cfg.classic)); }catch(_e){} }

    function loadCfg(){
      try{
        const raw = localStorage.getItem('partyhub_kalambury_cfg_classic');
        if(!raw) return;
        const parsed = JSON.parse(raw);
        if(!parsed || typeof parsed !== 'object') return;

        if(Number.isFinite(Number(parsed.turnSeconds))){
          const ts = Number(parsed.turnSeconds);
          state.cfg.classic.turnSeconds = (ts === 0) ? 0 : (TURN_STEPS.includes(ts) ? ts : 90);
        }

        if(Number.isFinite(Number(parsed.targetScore))){
          const t = Number(parsed.targetScore);
          state.cfg.classic.targetScore = (t === 0) ? 0 : (t >= 1 && t <= 7) ? t : 3;
        }

        if(Array.isArray(parsed.categories)){
          const allowed = new Set(CATEGORY_LIST.map(c=>c.id));
          const next = parsed.categories.map(x=>String(x)).filter(id=>allowed.has(id));
          state.cfg.classic.categories = next.length ? [...new Set(next)] : [];
        }
      }catch(_e){}
    }

    function applyCfgToUI(){
      const cfg = state.cfg.classic;
      if(cfgTurnSeconds){
        const idx = TURN_STEPS.lastIndexOf(cfg.turnSeconds);
        cfgTurnSeconds.value = String(idx >= 0 ? idx + 1 : 3);
      }
      syncTurnSecondsBadge();

      if(cfgTargetScore) cfgTargetScore.value = String(cfg.targetScore === 0 ? 8 : Math.min(7, Math.max(1, cfg.targetScore)));
      syncTargetScoreBadge();
      syncRoundSummary();
      syncCategoriesUI();
    }

    function readCfgFromUI(){
      if(cfgTurnSeconds){
        const raw = Number(cfgTurnSeconds.value) || 2;
        const v = TURN_STEPS[Math.min(TURN_STEPS.length-1, Math.max(0, raw-1))];
        state.cfg.classic.turnSeconds = v;
        cfgTurnSeconds.value = String(Math.min(8, Math.max(1, raw)));
        syncTurnSecondsBadge();
      }

      if(cfgTargetScore){
        const raw = Number(cfgTargetScore.value) || 1;
        state.cfg.classic.targetScore = (raw >= 8) ? 0 : Math.min(7, Math.max(1, raw));
        cfgTargetScore.value = String(state.cfg.classic.targetScore === 0 ? 8 : state.cfg.classic.targetScore);
        syncTargetScoreBadge();
      }

      saveCfg();
      syncRoundSummary();
      validateStart();
    }

    // ANCHOR: CATEGORIES_LOGIC
    const formatCatsSummary = (ids, max=4) => {
      const names = ids.map(id => (CATEGORY_LIST.find(x=>x.id===id)||{label:id}).label);
      const shown = names.slice(0, max);
      const rest = names.length - shown.length;
      return rest > 0 ? `${shown.join(', ')} +${rest}` : shown.join(', ');
    };

    function renderCategories(){
      if(!catsGrid) return;
      catsGrid.innerHTML = CATEGORY_LIST.map(c=>`<button type="button" class="cat-chip" data-cat="${c.id}">${c.label}</button>`).join('');
      syncCategoriesUI();
    }

    function syncCategoriesUI(){
      const cfg = state.cfg.classic;
      if(!Array.isArray(cfg.categories)) cfg.categories = [];
      const sel = new Set(cfg.categories);

      if(catsGrid) catsGrid.querySelectorAll('[data-cat]').forEach(b=>b.classList.toggle('selected', sel.has(b.dataset.cat)));
      if(catsSummary) catsSummary.textContent = !cfg.categories.length ? 'Wybierz min. 1' : ('Wybrane: ' + formatCatsSummary(cfg.categories, 4));
      if(catsCount) catsCount.textContent = `${cfg.categories.length}/${CATEGORY_LIST.length}`;
    }

    function toggleCategory(id){
      const cfg = state.cfg.classic;
      const next = new Set(Array.isArray(cfg.categories) ? cfg.categories : []);
      next.has(id) ? next.delete(id) : next.add(id);
      cfg.categories = [...next];
      saveCfg();
      syncCategoriesUI();
      validateStart();
    }

    function setAllCategories(){
      state.cfg.classic.categories = CATEGORY_LIST.map(c=>c.id);
      saveCfg();
      syncCategoriesUI();
      validateStart();
    }

    function clearCategories(){
      state.cfg.classic.categories = [];
      saveCfg();
      syncCategoriesUI();
      validateStart();
    }

    function randomCategories(){
      const ids = CATEGORY_LIST.map(c=>c.id);
      const maxPick = Math.min(3, ids.length);
      const count = 1 + Math.floor(Math.random()*maxPick);
      for(let i=ids.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        [ids[i],ids[j]]=[ids[j],ids[i]];
      }
      state.cfg.classic.categories = ids.slice(0,count);
      saveCfg();
      syncCategoriesUI();
      validateStart();
    }

    // ANCHOR: NAV
    function openModeSettings(){
      if(!state.selectedMode) return;
      loadMode();
      showOverlay(overlayModeSettings);
      applyCfgToUI();
      initSettingCards();
      renderPlayers();
      validateStart();
    }

    function backToHome(){ showOverlay(overlayHome); }

    // ANCHOR: NAV_TO_HUB
    function goToHub(){ window.location.href = '../../index.html'; }
    // ANCHOR: GAME_ENGINE (minimalny stage system — zaczynamy od STAGE 1 - Losowanie)

    // ANCHOR: STAGE_TEMPLATES
    function escHtml(s){
  return String(s ?? '').replace(/[&<>"']/g, (ch) => ({
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;',
  }[ch] || ch));
}


    function gridDimsForPlayers(n){
      const c = Math.max(0, (n|0));
      if(c <= 1) return { cols:1, rows:1 };
      if(c <= 4) return { cols:c, rows:1 };
      if(c <= 6) return { cols:3, rows:2 };
      return { cols:4, rows:2 }; // 7–8
    }

    // ANCHOR: SHUFFLE_UTIL (losowe ułożenie kart na planszy — niezależnie od listy w ustawieniach)
    function shuffleInPlace(arr){
      for(let i=arr.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        [arr[i],arr[j]] = [arr[j],arr[i]];
      }
      return arr;
    }

    function reshuffleStage1Layout(){
      // Układ kart na planszy ma być LOSOWY i NIEZALEŻNY od kolejności w menu ustawień.
      // Jeśli wypadnie identyczna kolejność jak w menu (rzadko), wymuszamy inną (dla 2+ graczy).
      const base = Array.isArray(players)
        ? players.map(p=>p && p.id).filter(Boolean).map(String)
        : [];

      if(base.length <= 1){
        state.game.layoutIds = base;
        return;
      }

      const sameOrder = (a,b)=>{
        if(!a || !b || a.length !== b.length) return false;
        for(let i=0;i<a.length;i++){ if(String(a[i]) !== String(b[i])) return false; }
        return true;
      };

      let ids = base.slice();
      for(let tries=0; tries<8; tries++){
        ids = base.slice();
        shuffleInPlace(ids);
        if(!sameOrder(ids, base)) break;
      }

      if(sameOrder(ids, base)){
        // safety (praktycznie nie powinno się zdarzyć) — rotacja gwarantuje inną kolejność
        ids = base.slice(1).concat(base[0]);
      }

      state.game.layoutIds = ids;
    }

    function getStage1LayoutPlayersOrdered(){
      const list = Array.isArray(players) ? players : [];
      if(!list.length) return [];

      // jeśli nie ma layoutu (np. dev-skip), wygeneruj
      if(!Array.isArray(state.game.layoutIds) || !state.game.layoutIds.length){
        reshuffleStage1Layout();
      }

      const map = new Map(list.map(p=>[String(p.id), p]));
      const ids = Array.isArray(state.game.layoutIds) ? state.game.layoutIds : [];
      let ordered = ids.map(id=>map.get(String(id))).filter(Boolean);

      // jeśli layout nieaktualny (zmiana graczy) — losuj od nowa
      if(ordered.length !== list.length){
        reshuffleStage1Layout();
        const ids2 = Array.isArray(state.game.layoutIds) ? state.game.layoutIds : [];
        ordered = ids2.map(id=>map.get(String(id))).filter(Boolean);
      }

      return ordered;
    }

    function tplPlayerPill(p){
      const emoji = (p && p.emoji) ? p.emoji : '🙂';
      const name = (p && p.name) ? p.name : 'Gracz';
      const score = (p && Number.isFinite(Number(p.score))) ? Number(p.score) : 0;
      const pid = (p && p.id) ? String(p.id) : '';

      // pozycja w wylosowanej kolejności (0 = jeszcze nie wylosowany)
      const pos = (state && state.game && state.game.orderPos && pid && state.game.orderPos[pid])
        ? Number(state.game.orderPos[pid])
        : 0;

      const picked = (pos > 0);
      const facedown = !picked;

      const focusId = (state && state.game && state.game.focusId) ? String(state.game.focusId) : '';
      const isFocus = !!(focusId && pid && pid === focusId);

      return `
        <div class="player-pill${facedown ? ' is-facedown' : ''}${picked ? ' stage1-picked' : ''}${isFocus ? ' roll-focus' : ''}" data-player-id="${pid}">
          <div class="pp-order${pos ? '' : ' is-hidden'}">${pos ? pos : ''}</div>
          <div class="pp-emoji">${emoji}</div>
          <div class="pp-meta">
            <div class="pp-name">${escHtml(name)}</div>
            <div class="pp-score"><span class="pp-score-num">${score}</span></div>
          </div>
        </div>
      `;
    }

    function tplStage1(){
      const list = getStage1LayoutPlayersOrdered();
      const n = list.length;
      const dims = gridDimsForPlayers(n);

      const cards = n
        ? list.map(p=>tplPlayerPill(p)).join('')
        : `<div class="stage-desc" style="grid-column:1/-1;align-self:center;justify-self:center;opacity:.78">Dodaj graczy w ustawieniach.</div>`;

      return `
        <div class="stage stage-1" data-dbg2="STAGE_1" aria-label="Stage 1 - Losowanie">
          <div class="stage-card" data-dbg2="STAGE_CARD">
            <div class="stage1-grid" data-dbg2="STAGE1_GRID" style="--cols:${dims.cols};--rows:${dims.rows}" aria-label="Karty graczy (rewers)">
              ${cards}
            </div>
          </div>
        </div>
      `;
    }

    // ANCHOR: STAGE2 (Start rundy)
    function ensureOrderForStage2(){
      const list = Array.isArray(players) ? players.map(p=>p && p.id).filter(Boolean).map(String) : [];
      const haveFull = Array.isArray(state.game.orderIds) && state.game.orderIds.length === list.length && list.length >= 2;
      if(!haveFull){
        // fallback: ustal kolejność na bazie aktualnego layoutu (albo listy graczy)
        const base = (Array.isArray(state.game.layoutIds) && state.game.layoutIds.length === list.length)
          ? state.game.layoutIds.slice().map(String)
          : list.slice();
        state.game.orderIds = base.slice();
        state.game.orderPos = {};
        state.game.orderIds.forEach((id,i)=>{ state.game.orderPos[String(id)] = i+1; });
      }
      if(!Number.isFinite(Number(state.game.presenterIdx))) state.game.presenterIdx = 0;
      if(state.game.presenterIdx < 0) state.game.presenterIdx = 0;
      if(state.game.presenterIdx >= ((state.game.orderIds && state.game.orderIds.length) ? state.game.orderIds.length : 0)) state.game.presenterIdx = 0;
    }

    function getPlayersInOrder(){
      const list = Array.isArray(players) ? players : [];
      if(!list.length) return [];
      if(Array.isArray(state.game.orderIds) && state.game.orderIds.length === list.length){
        const map = new Map(list.map(p=>[String(p.id), p]));
        const ordered = state.game.orderIds.map(id=>map.get(String(id))).filter(Boolean);
        if(ordered.length === list.length) return ordered;
      }
      return list.slice();
    }

    function getCurrentPresenterId(){
      ensureOrderForStage2();
      const ids = Array.isArray(state.game.orderIds) ? state.game.orderIds : [];
      return ids.length ? String(ids[state.game.presenterIdx] || ids[0]) : null;
    }

    function tplPresenterPill(p){
      const emoji = (p && p.emoji) ? p.emoji : '🙂';
      const name = (p && p.name) ? p.name : 'Gracz';
      const pid = (p && p.id) ? String(p.id) : '';
      return `
        <div class="player-pill presenter-pill" data-dbg2="PRESENTER_PILL" data-player-id="${pid}">
          <div class="pp-emoji">${emoji}</div>
          <div class="pp-name">${escHtml(name)}</div>
        </div>
      `;
    }

    function tplPlayerPillStage2(p, currentPresenterId){
      const emoji = (p && p.emoji) ? p.emoji : '🙂';
      const name = (p && p.name) ? p.name : 'Gracz';
      const score = (p && Number.isFinite(Number(p.score))) ? Number(p.score) : 0;
      const pid = (p && p.id) ? String(p.id) : '';

      const isCur = !!(currentPresenterId && pid && String(pid) === String(currentPresenterId));

      return `
        <div class="player-pill${isCur ? ' stage2-current' : ''}" data-player-id="${pid}">
          <div class="pp-emoji">${emoji}</div>
          <div class="pp-meta">
            <div class="pp-name">${escHtml(name)}</div>
            <div class="pp-score"><span class="pp-score-num">${score}</span></div>
          </div>
        </div>
      `;
    }

    function tplStage2(){
      ensureOrderForStage2();
      const ordered = getPlayersInOrder();
      const n = ordered.length;
      const dims = gridDimsForPlayers(n);

      const presenterId = getCurrentPresenterId();
      const presenter = ordered.find(p=>String(p.id)===String(presenterId)) || ordered[0] || null;

      const pills = n
        ? ordered.map(p=>tplPlayerPillStage2(p, presenterId)).join('')
        : `<div class="stage-desc" style="grid-column:1/-1;align-self:center;justify-self:center;opacity:.78">Dodaj graczy w ustawieniach.</div>`;

      const posTxt = presenterId && state && state.game && state.game.orderPos
        ? (state.game.orderPos[String(presenterId)] || (state.game.presenterIdx + 1))
        : (state.game.presenterIdx + 1);

      const drawerOpen = !!(state && state.game && state.game.stage2GridOpen);

      // dodatkowe info do TOP BAR (więcej niż tylko kolejka)
      const cfg = (state && state.cfg && state.cfg.classic) ? state.cfg.classic : { turnSeconds: 90, targetScore: 3, categories: [] };
      const turnTxt = (cfg.turnSeconds === 0) ? '∞' : `${cfg.turnSeconds}s`;
      const limitTxt = (cfg.targetScore === 0) ? '∞' : String(cfg.targetScore);
      const catsIds = Array.isArray(cfg.categories) ? cfg.categories : [];
      const catsTxt = catsIds.length ? formatCatsSummary(catsIds, 2) : '—';

      const nextP = (n >= 2) ? ordered[(state.game.presenterIdx + 1) % n] : null;
      const nextName = nextP ? (nextP.name || '—') : '—';

      let bestScore = -1;
      let leaderNames = [];
      ordered.forEach(pp=>{
        const sc = Number(pp && pp.score);
        const val = Number.isFinite(sc) ? sc : 0;
        if(val > bestScore){
          bestScore = val;
          leaderNames = [pp && pp.name ? pp.name : '—'];
        }else if(val === bestScore){
          leaderNames.push(pp && pp.name ? pp.name : '—');
        }
      });
      const leaderExtra = (leaderNames.length > 1) ? (' +' + (leaderNames.length - 1)) : '';
      const leaderTxt = (bestScore > 0)
        ? `${leaderNames[0]}${leaderExtra} (${bestScore})`
        : '—';

      const topMetaHtml = `
        <div class="stage2-chip" data-dbg2="STAGE2_CHIP"><span class="k">GRACZE</span><span class="v">${Math.max(0,n)}</span></div>
        <div class="stage2-chip" data-dbg2="STAGE2_CHIP"><span class="k">CZAS</span><span class="v">${escHtml(turnTxt)}</span></div>
        <div class="stage2-chip" data-dbg2="STAGE2_CHIP"><span class="k">LIMIT</span><span class="v">${escHtml(limitTxt)}</span></div>
        <div class="stage2-chip" data-dbg2="STAGE2_CHIP"><span class="k">KATEGORIE</span><span class="v">${escHtml(catsTxt)}</span></div>
        <div class="stage2-chip" data-dbg2="STAGE2_CHIP"><span class="k">NASTĘPNY</span><span class="v">${escHtml(nextName)}</span></div>
        <div class="stage2-chip" data-dbg2="STAGE2_CHIP"><span class="k">LIDER</span><span class="v">${escHtml(leaderTxt)}</span></div>
      `;
      if(state && state.game) state.game.topBarMetaHtml = topMetaHtml;

      return `
        <div class="stage stage-2" data-dbg2="STAGE_2" aria-label="Stage 2 - Start rundy">
          <div class="stage-card${drawerOpen ? ' stage2-sheet-open' : ''}" data-dbg2="STAGE_CARD">

            <div class="stage2-head" data-dbg2="STAGE2_HEAD">
              <div class="stage2-sub">Tura ${posTxt}/${Math.max(1,n)}</div>

              <div class="stage2-presenter" data-dbg2="STAGE2_PRESENTER" aria-label="Prezentuje">
                <div class="stage2-presenter-label" aria-hidden="true">PREZENTUJE</div>
                ${presenter ? tplPresenterPill(presenter) : ''}
              </div>
            </div>

            <div class="stage2-sheet${drawerOpen ? ' is-open' : ''}" data-dbg2="STAGE2_DRAWER" aria-label="Lista graczy (z dołu)">
              <button class="stage2-sheet-handle" data-dbg2="STAGE2_TOGGLE" id="btnStage2ToggleGrid" type="button" aria-expanded="${drawerOpen ? 'true' : 'false'}" aria-label="Pokaż/ukryj graczy">
                <span class="stage2-sheet-caret" aria-hidden="true">▴</span>
              </button>
              <div class="stage2-sheet-body">
                <div class="stage2-grid" data-dbg2="STAGE2_GRID" style="--cols:${dims.cols};--rows:${dims.rows}" aria-label="Gracze (kolejność gry)">
                  ${pills}
                </div>
              </div>
            </div>

          </div>
        </div>
      `;
    }

    // ANCHOR: STAGE2_DRAWER_BIND (zwijana lista graczy)
    function bindStage2Drawer(){
      const btn = $('btnStage2ToggleGrid');
      if(!btn || btn.dataset.bound === '1') return;
      btn.addEventListener('click', ()=>{
        const drawer = gameHud ? gameHud.querySelector('.stage2-sheet, .stage2-drawer') : null;
        if(!drawer) return;
        const isOpen = drawer.classList.toggle('is-open');
        const card = drawer.closest('.stage-card');
        if(card) card.classList.toggle('stage2-sheet-open', isOpen);
        if(state && state.game) state.game.stage2GridOpen = isOpen;
        btn.setAttribute('aria-expanded', isOpen ? 'true' : 'false');
      });
      btn.dataset.bound = '1';
    }

    function goStage2FromStage1(){
      const total = Array.isArray(players) ? players.length : 0;
      const done = total >= 2 && Array.isArray(state.game.orderIds) && state.game.orderIds.length === total;
      if(!done) return;

      clearStage1Timers();
      state.game.rolling = false;
      state.game.focusId = null;
      state.game.presenterIdx = 0;
      state.game.stage2GridOpen = false;

      setGameStage('stage2');
    }


    // ANCHOR: STAGE1_ROLL_ORDER (skakanie focusa + wybór karty + flip + kolejny cykl)
    let __rollT = null;
    let __afterPickT = null;

    function clearStage1Timers(){
      if(__rollT){ clearTimeout(__rollT); __rollT = null; }
      if(__afterPickT){ clearTimeout(__afterPickT); __afterPickT = null; }
    }

    function resetStage1OrderState(){
      state.game.orderIds = [];
      state.game.orderPos = {};
      state.game.focusId = null;
      state.game.forceDeck = false;
    }

    function stage1IsActive(){
      return !!(state && state.game && state.game.stage === 'stage1');
    }

    function getStage1Grid(){
      return gameHud ? gameHud.querySelector('.stage1-grid') : null;
    }

    function getStage1Cards(){
      const grid = getStage1Grid();
      if(!grid) return [];
      return Array.from(grid.querySelectorAll('.player-pill[data-player-id]'));
    }

    // ANCHOR: STAGE1_DECK_ANIM (deck -> grid "rozłożenie" po kliknięciu losowania)
    function stage1MotionEnabled(){
      if(document.body.classList.contains('motion-off')) return false;
      // jeśli user wyłączył animacje w ustawieniach
      if(state && state.settings && state.settings.motionOn === false) return false;
      return true;
    }

    // ANCHOR: STAGE1_DECK_ANIM_TOKENS (płynniejsze składanie/rozkładanie)
    const STAGE1_DECK_ANIM = {
      spreadDur: 740,
      spreadStagger: 52,
      stackDur: 520,
      stackStagger: 34,
      easing: 'cubic-bezier(.16,1,.3,1)',
      blurPx: 0.6,
      fade: 0.03
    };

    function setStage1DeckMode(on){
      const grid = getStage1Grid();
      if(!grid) return;
      grid.classList.toggle('is-deck', !!on);
    }

    function spreadStage1DeckThen(cb){
      const grid = getStage1Grid();
      if(!grid) return cb && cb();
      if(!grid.classList.contains('is-deck')) return cb && cb();

      // bez animacji (motion-off) => tylko przełącz layout
      if(!stage1MotionEnabled()){
        grid.classList.remove('is-deck');
        return cb && cb();
      }

      const cards = getStage1Cards();
      if(!cards.length){
        grid.classList.remove('is-deck');
        return cb && cb();
      }

      // FLIP: First
      const first = new Map();
      cards.forEach(el=>first.set(el, el.getBoundingClientRect()));

      // przełącz na grid
      grid.classList.remove('is-deck');

      requestAnimationFrame(()=>{
        // FLIP: Last
        const last = new Map();
        cards.forEach(el=>last.set(el, el.getBoundingClientRect()));

        // FLIP: Invert
        cards.forEach((el, i)=>{
          const a = first.get(el);
          const b = last.get(el);
          if(!a || !b) return;

          const dx = a.left - b.left;
          const dy = a.top - b.top;
          const sx = b.width ? (a.width / b.width) : 1;
          const sy = b.height ? (a.height / b.height) : 1;

          el.style.willChange = 'transform, filter, opacity';
          el.style.transition = 'transform 0s, filter 0s, opacity 0s';
          el.style.transform = `translate3d(${dx}px, ${dy}px, 0) scale(${sx}, ${sy})`;
          el.style.opacity = String(1 - (STAGE1_DECK_ANIM.fade || 0));
          el.style.filter = `blur(${STAGE1_DECK_ANIM.blurPx || 0}px)`;
          el.style.removeProperty('transition-delay');
        });

        requestAnimationFrame(()=>{
          let pending = cards.length;
          const maxStagger = Math.min(7, cards.length - 1);

          const cleanup = () => {
            cards.forEach(el=>{
              el.style.willChange = '';
              el.style.transition = '';
              el.style.filter = '';
              el.style.opacity = '';
              el.style.transform = '';
              el.style.removeProperty('transition-delay');
            });
          };

          const doneOne = () => {
            pending--;
            if(pending <= 0){
              cleanup();
              if(cb) cb();
            }
          };

          cards.forEach((el, i)=>{
            const delay = Math.min(i, maxStagger) * (STAGE1_DECK_ANIM.spreadStagger || 0);
            const dur = (STAGE1_DECK_ANIM.spreadDur || 680);
            const ease = (STAGE1_DECK_ANIM.easing || 'cubic-bezier(.2,.9,.2,1)');
            el.style.transition = `transform ${dur}ms ${ease}, filter ${dur}ms ${ease}, opacity ${dur}ms ${ease}`;
            el.style.transitionDelay = delay + 'ms';

            const onEnd = (ev) => {
              if(ev.propertyName !== 'transform') return;
              el.removeEventListener('transitionend', onEnd);
              doneOne();
            };
            el.addEventListener('transitionend', onEnd);

            // FLIP: Play
            el.style.opacity = '1';
            el.style.filter = 'blur(0px)';
            el.style.transform = '';
          });

          // safety timeout
          setTimeout(()=>{
            if(pending > 0){
              pending = 0;
              cleanup();
              if(cb) cb();
            }
          }, (STAGE1_DECK_ANIM.spreadDur || 680) + 600 + (maxStagger * (STAGE1_DECK_ANIM.spreadStagger || 45)) );
        });
      });
    }

    // ANCHOR: STAGE1_DECK_STACK (grid -> deck "złożenie" po zakończeniu losowania)
    function stackStage1GridToDeckThen(cb){
      const grid = getStage1Grid();
      if(!grid) return cb && cb();
      if(grid.classList.contains('is-deck')) return cb && cb();

      if(!stage1MotionEnabled()){
        grid.classList.add('is-deck');
        return cb && cb();
      }

      const cards = getStage1Cards();
      if(!cards.length){
        grid.classList.add('is-deck');
        return cb && cb();
      }

      // FLIP: First (grid)
      const first = new Map();
      cards.forEach(el=>first.set(el, el.getBoundingClientRect()));

      // przełącz na deck
      grid.classList.add('is-deck');

      requestAnimationFrame(()=>{
        // FLIP: Last (deck)
        const last = new Map();
        cards.forEach(el=>last.set(el, el.getBoundingClientRect()));

        // FLIP: Invert
        cards.forEach((el)=>{
          const a = first.get(el);
          const b = last.get(el);
          if(!a || !b) return;

          const dx = a.left - b.left;
          const dy = a.top - b.top;
          const sx = b.width ? (a.width / b.width) : 1;
          const sy = b.height ? (a.height / b.height) : 1;

          el.style.willChange = 'transform, filter, opacity';
          el.style.transition = 'transform 0s, filter 0s, opacity 0s';
          el.style.transform = `translate3d(${dx}px, ${dy}px, 0) scale(${sx}, ${sy})`;
          el.style.opacity = String(1 - (STAGE1_DECK_ANIM.fade || 0));
          el.style.filter = `blur(${STAGE1_DECK_ANIM.blurPx || 0}px)`;
          el.style.removeProperty('transition-delay');
        });

        requestAnimationFrame(()=>{
          let pending = cards.length;
          const maxStagger = Math.min(7, cards.length - 1);

          const cleanup = () => {
            cards.forEach(el=>{
              el.style.willChange = '';
              el.style.transition = '';
              el.style.filter = '';
              el.style.opacity = '';
              el.style.transform = '';
              el.style.removeProperty('transition-delay');
            });
          };

          const doneOne = () => {
            pending--;
            if(pending <= 0){
              cleanup();
              if(cb) cb();
            }
          };

          cards.forEach((el, i)=>{
            const delay = Math.min(i, maxStagger) * (STAGE1_DECK_ANIM.stackStagger || 0);
            const dur = (STAGE1_DECK_ANIM.stackDur || 460);
            const ease = (STAGE1_DECK_ANIM.easing || 'cubic-bezier(.2,.9,.2,1)');
            el.style.transition = `transform ${dur}ms ${ease}, filter ${dur}ms ${ease}, opacity ${dur}ms ${ease}`;
            el.style.transitionDelay = delay + 'ms';

            const onEnd = (ev) => {
              if(ev.propertyName !== 'transform') return;
              el.removeEventListener('transitionend', onEnd);
              doneOne();
            };
            el.addEventListener('transitionend', onEnd);

            // FLIP: Play
            el.style.opacity = '1';
            el.style.filter = 'blur(0px)';
            el.style.transform = '';
          });

          // safety timeout
          setTimeout(()=>{
            if(pending > 0){
              pending = 0;
              cleanup();
              if(cb) cb();
            }
          }, (STAGE1_DECK_ANIM.stackDur || 460) + 360 + (maxStagger * (STAGE1_DECK_ANIM.stackStagger || 28)) );
        });
      });
    }

    // ANCHOR: STAGE1_FINALIZE_ORDER (po wylosowaniu wszystkich: złożenie do środka -> układ 1..N)
    function finalizeStage1AfterAllPicked(){
      if(!stage1IsActive()) return finishStage1Roll();

      const total = Array.isArray(players) ? players.length : 0;
      const done = total >= 2 && Array.isArray(state.game.orderIds) && state.game.orderIds.length === total;
      if(!done) return finishStage1Roll();

      clearStage1Timers();
      state.game.focusId = null;
      getStage1Cards().forEach(x=>x.classList.remove('roll-focus'));

      const grid = getStage1Grid();
      if(grid) grid.classList.add('is-rolling');
      renderBottomBar();

      // 1) złóż do decka (avatary już są odkryte)
      stackStage1GridToDeckThen(()=>{
        // 2) docelowy układ wg kolejności 1..N
        state.game.layoutIds = state.game.orderIds.slice().map(String);

        // 3) wyrenderuj w trybie deck, żeby rozłożyć do nowego układu
        state.game.forceDeck = true;
        renderGameStage();

        const grid2 = getStage1Grid();
        if(grid2) grid2.classList.add('is-rolling');

        // 4) rozłóż z decka do siatki — już w kolejności 1..N
        spreadStage1DeckThen(()=>{
          state.game.forceDeck = false;
          finishStage1Roll();
        });
      });
    }

    function getRemainingStage1Cards(){
      const all = getStage1Cards();
      return all.filter(el=>{
        const id = el.dataset.playerId;
        return id && !(state.game.orderPos && state.game.orderPos[id]);
      });
    }

    function setFocusCard(el){
      const all = getStage1Cards();
      all.forEach(x=>x.classList.remove('roll-focus'));
      if(el) el.classList.add('roll-focus');
      state.game.focusId = el ? (el.dataset.playerId || null) : null;
    }

    function revealPickedCard(el, pos){
      if(!el) return;
      el.classList.remove('is-facedown');
      el.classList.add('stage1-picked');
      const badge = el.querySelector('.pp-order');
      if(badge){
        badge.textContent = String(pos);
        badge.classList.remove('is-hidden');
      }
    }

    function finishStage1Roll(){
      state.game.rolling = false;
      state.game.focusId = null;
      clearStage1Timers();

      const grid = getStage1Grid();
      if(grid) grid.classList.remove('is-rolling');

      // usuń focus
      getStage1Cards().forEach(x=>x.classList.remove('roll-focus'));

      renderBottomBar();
    }

    function rollStage1Order(){
      if(!state || !state.game) return;
      if(!stage1IsActive()) return;
      if(state.game.rolling) return;

      const list = Array.isArray(players) ? players : [];
      if(list.length < 2) return;

      // reset + rerender => wszystkie karty z powrotem rewersem + "deck"
      clearStage1Timers();
      resetStage1OrderState();
      reshuffleStage1Layout();
      renderGameStage();

      const grid = getStage1Grid();
      const allCards = getStage1Cards();
      if(!grid || allCards.length < 2) return;

      // blokuj przycisk już podczas rozkładania
      state.game.rolling = true;
      grid.classList.add('is-rolling');
      renderBottomBar();

      const runCycle = () => {
        if(!stage1IsActive() || !state.game.rolling) return finishStage1Roll();

        const remaining = getRemainingStage1Cards();
        if(remaining.length === 0) return finishStage1Roll();

        let prevIdx = -1;
        const isLastCard = (remaining.length === 1);
        const total = isLastCard ? 6 : Math.max(10, Math.round(remaining.length * 1.25) + 5 + Math.floor(Math.random()*3));
        let step = 0;

        const tick = () => {
          if(!stage1IsActive() || !state.game.rolling) return finishStage1Roll();

          // (remaining w tym cyklu jest stałe)
          let idx = 0;
          if(remaining.length === 1) idx = 0;
          else{
            do{ idx = Math.floor(Math.random()*remaining.length); }while(idx === prevIdx);
          }

          const el = remaining[idx];
          setFocusCard(el);
          prevIdx = idx;

          step++;
          const t = step / total;
          const delay = isLastCard
            ? Math.round(55 + (t*t) * 90)  // ostatnia karta: szybciej
            : Math.round(95 + (t*t) * 160); // ease-out (wolniej, ale krócej całościowo)

          if(step < total){
            __rollT = setTimeout(tick, delay);
            return;
          }

          // WYBÓR: wylosowana karta
          const picked = remaining[idx];
          const pid = picked ? picked.dataset.playerId : null;
          if(!pid) return finishStage1Roll();

          const pos = (Array.isArray(state.game.orderIds) ? state.game.orderIds.length : 0) + 1;
          state.game.orderIds = Array.isArray(state.game.orderIds) ? state.game.orderIds : [];
          state.game.orderIds.push(pid);
          state.game.orderPos[pid] = pos;

          // flip + badge
          revealPickedCard(picked, pos);

          // jeśli to ostatnia karta: złóż do środka i rozłóż w kolejności 1..N
          const totalNow = Array.isArray(players) ? players.length : 0;
          if(pos >= totalNow){
            __afterPickT = setTimeout(() => {
              if(!stage1IsActive() || !state.game.rolling) return finishStage1Roll();
              finalizeStage1AfterAllPicked();
            }, 260);
            return;
          }

          // chwilka na animację i następny cykl (z pominięciem wylosowanych)
          __afterPickT = setTimeout(() => {
            if(!stage1IsActive() || !state.game.rolling) return finishStage1Roll();
            runCycle();
          }, 340);
        };

        tick();
      };

      // Najpierw: rozłóż karty z decka do siatki, potem start losowania.
      spreadStage1DeckThen(() => {
        runCycle();
      });
    }

// ANCHOR: STAGE_RENDER
    function renderBottomBar(){
      if(!bottomBar) return;
      const s = (state && state.game && state.game.stage) ? state.game.stage : 'idle';

      if(s === 'stage1'){
        const rolling = !!(state && state.game && state.game.rolling);
        const total = Array.isArray(players) ? players.length : 0;
        const done = !rolling && total >= 2 && Array.isArray(state.game.orderIds) && state.game.orderIds.length === total;

        if(done){
          bottomBar.innerHTML =
            `<div class="bb-actions">
               <button class="btn-ghost btn-lg bb-side" id="btnRollAgain" type="button">Losuj ponownie</button>
               <button class="btn-new btn-lg bb-main" id="btnGoStage2" type="button">Dalej</button>
             </div>`;

          const b1 = $('btnRollAgain');
          if(b1 && b1.dataset.bound !== '1'){
            b1.addEventListener('click', ()=>{
              if(state && state.game && state.game.rolling) return;
              rollStage1Order();
            });
            b1.dataset.bound = '1';
          }

          const b2 = $('btnGoStage2');
          if(b2 && b2.dataset.bound !== '1'){
            b2.addEventListener('click', ()=>goStage2FromStage1());
            b2.dataset.bound = '1';
          }
          return;
        }

        const label = rolling ? 'Losuję…' : 'Losowanie kolejności';

        bottomBar.innerHTML =
          `<button class="btn-new btn-lg btn-roll-order" id="btnRollOrder" type="button" ${rolling ? 'disabled' : ''}>${label}</button>`;

        const b = $('btnRollOrder');
        if(b && b.dataset.bound !== '1'){
          b.addEventListener('click', ()=>{
            if(state && state.game && state.game.rolling) return;
            rollStage1Order();
          });
          b.dataset.bound = '1';
        }
        return;
      }

      if(s === 'stage2'){
        bottomBar.innerHTML =
          `<div class="bb-actions">
             <button class="btn-back btn-lg bb-side" id="btnStage2Back" type="button">← Losowanie</button>
             <button class="btn-new btn-lg bb-main" id="btnStage2StartTurn" type="button">Start tury</button>
           </div>`;

        const bBack = $('btnStage2Back');
        if(bBack && bBack.dataset.bound !== '1'){
          bBack.addEventListener('click', ()=>setGameStage('stage1'));
          bBack.dataset.bound = '1';
        }

        const bStart = $('btnStage2StartTurn');
        if(bStart && bStart.dataset.bound !== '1'){
          bStart.addEventListener('click', ()=>{
            openConfirm({
              title:'W trakcie budowy',
              message:'STAGE 3 (czas tury) dopniemy jako następny krok 🙂',
              okText:'OK',
              cancelText:'Zamknij',
              okClass:'btn-new',
              onConfirm: ()=>{}
            });
          });
          bStart.dataset.bound = '1';
        }
        return;
      }

      bottomBar.innerHTML = '';
    }

    function renderGameStage(){
      if(!gameHud) return;
      const s = (state && state.game && state.game.stage) ? state.game.stage : 'idle';

      if(s === 'stage1'){
        gameHud.innerHTML = tplStage1();
        applyTwemoji(gameHud);

        // Na wejściu do STAGE 1: pokaż "deck" (karty na sobie rewersem) dopóki nie zacznie się losowanie.
        const grid = getStage1Grid();
        const anyPicked = !!(state && state.game && Array.isArray(state.game.orderIds) && state.game.orderIds.length);
        const forceDeck = !!(state && state.game && state.game.forceDeck);
        if(grid){
          if(forceDeck) grid.classList.add('is-deck');
          else grid.classList.toggle('is-deck', !anyPicked && !(state && state.game && state.game.rolling));
        }

        renderBottomBar();
        return;
      }

      if(s === 'stage2'){
        gameHud.innerHTML = tplStage2();
      bindStage2Drawer();
        applyTwemoji(gameHud);
        bindStage2Drawer();
        renderBottomBar();
        return;
      }

      // default: IDLE
      gameHud.innerHTML = '';
      renderBottomBar();
    }

    // ANCHOR: START_TO_STAGE1
    function openGameScreen(){
      showOverlay(overlayGame);

      // START => zawsze zaczynamy od "deck" (karty na sobie rewersem)
      clearStage1Timers();
      resetStage1OrderState();
      reshuffleStage1Layout();
      state.game.rolling = false;
      state.game.focusId = null;
      state.game.presenterIdx = 0;

      setGameStage('stage1');
    }

    // ANCHOR: PLAYERS_SYSTEM (1:1 z 5 Sekund)

    const EMOJI_GROUPS = {
      people:["🙂","😀","😄","😁","😆","😅","😂","😉","😊","😇","😍","🤩","🥳","😎","🤓","🤠","😴","🤯","😤","😱","🧑","👩","👨","🧔","👱‍♀️","👱‍♂️","👩‍🦰","👨‍🦳"],
      animals:["🐶","🐱","🐭","🐹","🐰","🦊","🐻","🐼","🐨","🐯","🦁","🐷","🐸","🐵","🐔","🐧","🐙","🦄","🐺","🐴"],
      other:["🤖","👽","💎","🔮","🎯","🎪","🎭","🎨","🏆","🥇","👑","💀","🦇","🌟","⭐","✨","🔥","⚡","💥","🌈"]
    };
    const EMOJIS = [...EMOJI_GROUPS.people, ...EMOJI_GROUPS.animals, ...EMOJI_GROUPS.other];
players = [];
draftPlayer = null; // ANCHOR: PLAYER_DRAFT (bez mignięcia placeholdera na liście)
    let emojiPickerCategory = 'people';
emojiPickerForId = null;
tempSelectedEmoji = null;

    function cryptoId(){ return Math.random().toString(16).slice(2)+Date.now().toString(16); }

    function validateStart(){
      const hasMinPlayers = players.length >= 2;
      const allHaveEmoji = players.every(p => p.emoji && p.emoji !== '+');
      const hasCats = Array.isArray(state.cfg.classic.categories) && state.cfg.classic.categories.length >= 1;
      const canStart = !!state.selectedMode && hasMinPlayers && allHaveEmoji && validateCfg();
      if(btnStartGame) btnStartGame.disabled = !canStart;

      const hint = $('startHint');
      if(!hint) return;
      const parts = [];
      if(!hasMinPlayers) parts.push('Dodaj min. 2 graczy');
      if(!allHaveEmoji) parts.push('Uzupełnij avatary');
      if(!hasCats) parts.push('Wybierz min. 1 kategorię');
      hint.textContent = parts.length ? ('Aby rozpocząć: ' + parts.join(' • ')) : '';
    }

    function addPlayer(){
      if(players.length>=8) return;
      const newId = cryptoId();
      draftPlayer = { id:newId, name:'', emoji:'+', score:0, wins:0 };
      openEmojiPicker(newId, true);
    }

    function removePlayer(id){
      const i = players.findIndex(p=>p.id===id);
      if(i>=0) players.splice(i,1);
      renderPlayers();
      validateStart();
      saveMode();
    }

    function findEmojiCategory(emoji){
      if(EMOJI_GROUPS.people.includes(emoji)) return 'people';
      if(EMOJI_GROUPS.animals.includes(emoji)) return 'animals';
      if(EMOJI_GROUPS.other.includes(emoji)) return 'other';
      return 'people';
    }

    function openEmojiPicker(id, isNew=false){
      const title = $('emojiPickerTitle');
      if(title) title.textContent = isNew ? 'Nowy gracz' : 'Edytuj gracza';
      emojiPickerForId = id;

      const p = players.find(x=>x.id===id) || (draftPlayer && draftPlayer.id===id ? draftPlayer : null);
      tempSelectedEmoji = (!isNew && p && p.emoji && p.emoji !== '+') ? p.emoji : null;

      const nameInput = $('emojiPickerNameInput');
      if(nameInput){
        nameInput.value = (p && p.name) ? p.name : '';
        nameInput.placeholder = isNew ? 'Nazwa gracza (min. 3 znaki)' : 'Wpisz nazwę...';
      }

      emojiPickerCategory = isNew ? 'people' : findEmojiCategory(p ? p.emoji : null);
      syncEmojiTabs();
      renderEmojiGrid();

      const err = $('emojiPickerError');
      if(err){ err.textContent = ''; err.classList.add('is-hidden'); err.classList.remove('txt-error'); }

      updateEmojiPickerConfirmButton();
      showO('emojiPickerOverlay');
      setTimeout(()=>{ if(nameInput) nameInput.focus(); }, 200);
    }

    function setEmojiCategory(cat){
      emojiPickerCategory = (cat==='animals' || cat==='other') ? cat : 'people';
      syncEmojiTabs();
      renderEmojiGrid();
    }

    function syncEmojiTabs(){
      const a = $('emojiTabPeople'), b = $('emojiTabAnimals'), c = $('emojiTabOther');
      if(a) a.classList.toggle('selected', emojiPickerCategory==='people');
      if(b) b.classList.toggle('selected', emojiPickerCategory==='animals');
      if(c) c.classList.toggle('selected', emojiPickerCategory==='other');
    }

    function renderEmojiGrid(){
      const grid = $('emojiGrid');
      if(!grid) return;
      grid.innerHTML = '';

      const p = players.find(x=>x.id===emojiPickerForId) || (draftPlayer && draftPlayer.id===emojiPickerForId ? draftPlayer : null);
      const selected = tempSelectedEmoji || (p ? p.emoji : null);

      const taken = new Set(players.filter(pp=>pp.id!==emojiPickerForId).map(pp=>pp.emoji));

      const list = (emojiPickerCategory==='animals') ? EMOJI_GROUPS.animals
        : (emojiPickerCategory==='other') ? EMOJI_GROUPS.other
          : EMOJI_GROUPS.people;

      list.forEach(e=>{
        const b=document.createElement('button');
        b.type='button';
        b.dataset.emoji=e;
        const isTaken = taken.has(e);
        b.disabled = isTaken;
        b.className='emoji-btn' + (e===selected ? ' selected' : '') + (isTaken ? ' disabled' : '');
        b.textContent=e;
        if(!isTaken) b.addEventListener('click', ()=>selectEmojiTemporary(e));
        grid.appendChild(b);
      });

      applyTwemoji(grid);
    }

    function selectEmojiTemporary(emoji){
      tempSelectedEmoji = emoji;
      const grid = $('emojiGrid');
      if(grid) grid.querySelectorAll('.emoji-btn').forEach(b=>b.classList.toggle('selected', b.dataset.emoji===emoji));
      updateEmojiPickerConfirmButton();
    }

    function updateEmojiPickerConfirmButton(){
      const btn = $('btnConfirmEmoji');
      const nameInput = $('emojiPickerNameInput');
      const err = $('emojiPickerError');

      const p = players.find(x=>x.id===emojiPickerForId) || (draftPlayer && draftPlayer.id===emojiPickerForId ? draftPlayer : null);
      const baseEmoji = p ? p.emoji : null;
      const effectiveEmoji = tempSelectedEmoji || baseEmoji;

      const nameRaw = nameInput ? nameInput.value.trim() : '';
      const nameOk = nameRaw.length >= 3;
      const emojiOk = effectiveEmoji && effectiveEmoji !== '+';

      const nName = normName(nameRaw);
      const nameTaken = !!(nName && players.some(pp => pp.id !== emojiPickerForId && normName(pp.name) === nName));
      const emojiTaken = !!(emojiOk && players.some(pp => pp.id !== emojiPickerForId && pp.emoji === effectiveEmoji));

      let msg = '';
      if(nameOk && nameTaken) msg = 'Ta nazwa jest już zajęta.';
      else if(emojiOk && emojiTaken) msg = 'Ten avatar jest już zajęty.';

      const canConfirm = !!(nameOk && emojiOk && !nameTaken && !emojiTaken);
      if(btn) btn.disabled = !canConfirm;

      if(err){
        err.textContent = msg;
        err.classList.toggle('is-hidden', !msg);
        err.classList.toggle('txt-error', !!msg);
      }
    }

    function confirmEmojiPicker(){
      const p0 = players.find(x=>x.id===emojiPickerForId) || (draftPlayer && draftPlayer.id===emojiPickerForId ? draftPlayer : null);
      const selectedEmoji = tempSelectedEmoji || (p0 ? p0.emoji : null);
      if(!selectedEmoji || selectedEmoji === '+') return;

      const nameInput = $('emojiPickerNameInput');
      const name = nameInput ? nameInput.value.trim() : '';
      if(name.length < 3) return;

      const nName = normName(name);
      const nameTaken = !!(nName && players.some(pp => pp.id !== emojiPickerForId && normName(pp.name) === nName));
      const emojiTaken = !!players.some(pp => pp.id !== emojiPickerForId && pp.emoji === selectedEmoji);
      if(nameTaken || emojiTaken){ updateEmojiPickerConfirmButton(); return; }

      if(draftPlayer && draftPlayer.id === emojiPickerForId && !players.some(x=>x.id===emojiPickerForId)){
        draftPlayer.emoji = selectedEmoji;
        draftPlayer.name = name;
        players.push(draftPlayer);
        draftPlayer = null;
        saveMode();
        renderPlayers();
        validateStart();
        hideO('emojiPickerOverlay');
        tempSelectedEmoji = null;
        emojiPickerForId = null;
        return;
      }

      const p = players.find(x=>x.id===emojiPickerForId);
      if(!p) return;
      p.emoji = selectedEmoji;
      p.name = name;
      saveMode();
      renderPlayers();
      validateStart();
      hideO('emojiPickerOverlay');
      tempSelectedEmoji = null;
      emojiPickerForId = null;
    }

    function cancelEmojiPicker(){
      if(draftPlayer && draftPlayer.id === emojiPickerForId && !players.some(x=>x.id===emojiPickerForId)){
        draftPlayer = null;
        hideO('emojiPickerOverlay');
        tempSelectedEmoji = null;
        emojiPickerForId = null;
        validateStart();
        return;
      }
      hideO('emojiPickerOverlay');
      tempSelectedEmoji = null;
      emojiPickerForId = null;
    }

    function renderPlayers(){
      const list = $('playersList');
      if(!list) return;
      list.innerHTML = '';

      players.forEach(p=>{
        const row = document.createElement('div');
        row.className = 'player-row';
        row.dataset.playerId = p.id;

        const emojiDisplay = document.createElement('div');
        emojiDisplay.className = 'player-emoji-display';
        emojiDisplay.textContent = p.emoji;

        const nameDisplay = document.createElement('div');
        nameDisplay.className = 'player-name-display';
        nameDisplay.textContent = p.name;

        const editBtn = document.createElement('button');
        editBtn.type = 'button';
        editBtn.className = 'player-edit';
        editBtn.textContent = '✏️';
        editBtn.addEventListener('click', ()=>openEmojiPicker(p.id,false));

        const del = document.createElement('button');
        del.type = 'button';
        del.className = 'player-del';
        del.textContent = '✖';
        del.addEventListener('click', ()=>removePlayer(p.id));

        row.append(emojiDisplay, nameDisplay, editBtn, del);
        list.appendChild(row);
      });

      if(playersSummary) playersSummary.textContent = `${players.length}/8`;
      const isFull = players.length >= 8;
      if(addPlayerBtn) addPlayerBtn.disabled = isFull;
      if(playersLimit) playersLimit.classList.toggle('is-hidden', !isFull);
      applyTwemoji(list);
      scheduleFitNames();
    }

    function saveMode(){
      try{
        const payload = { players: players.map(p=>({ id:p.id, name:p.name, emoji:p.emoji, wins:p.wins||0 })) };
        localStorage.setItem('partyhub_kalambury_mode', JSON.stringify(payload));
      }catch(_e){}
    }

    function loadMode(){
      try{
        const s = localStorage.getItem('partyhub_kalambury_mode');
        if(!s) return;
        const m = JSON.parse(s);
        if(!m || !Array.isArray(m.players)) return;

        let changed = false;
        const usedNames = new Set();
        const usedEmoji = new Set();
        const next = [];

        const pickEmoji = (raw) => {
          const e0 = String(raw||'').trim();
          let e = (e0 && e0 !== '+' && EMOJIS.includes(e0)) ? e0 : EMOJI_GROUPS.people[0];
          if(e !== e0) changed = true;

          if(!usedEmoji.has(e)){ usedEmoji.add(e); return e; }

          changed = true;
          for(const cand of EMOJIS){
            if(!usedEmoji.has(cand)){ usedEmoji.add(cand); return cand; }
          }
          return null;
        };

        const pickName = (raw, idx) => {
          const base0 = String(raw||'').trim().replace(/\s+/g,' ');
          const base = base0.length ? base0 : ('Gracz ' + (idx+1));
          if(base !== base0) changed = true;

          let name = base;
          let n = 2;
          while(usedNames.has(normName(name))){ name = base + ' ' + (n++); changed = true; }
          usedNames.add(normName(name));
          return name;
        };

        m.players.slice(0, 50).forEach((pp, idx)=>{
          if(!pp || next.length>=8) return;

          const idIn = pp.id;
          const id = String(pp.id || cryptoId());
          if(String(idIn||'') !== id) changed = true;

          const emoji = pickEmoji(pp.emoji);
          if(!emoji) return;

          const name = pickName(pp.name, idx);

          const winsRaw = parseInt(pp.wins, 10);
          const wins = Number.isFinite(winsRaw) ? Math.max(0, winsRaw) : 0;
          if(wins !== (pp.wins||0)) changed = true;

          next.push({ id, name, emoji, score:0, wins });
        });

        players = next;
        if(changed) saveMode();
      }catch(_e){}
    }

    // ANCHOR: EVENTS
    document.querySelectorAll('.mode-card').forEach(card => {
      const header = card.querySelector('.mode-header');
      const btnPlay = card.querySelector('[data-mode-play]');
      const btnInfo = card.querySelector('[data-mode-info]');

      if(header){
        header.addEventListener('click', () => {
          const modeId = card.dataset.mode;
          toggleModeCard(card);
          if(modeId === 'wip') return;
          selectMode(modeId);
        });

        header.addEventListener('keydown', (e) => {
          if(e.key === 'Enter' || e.key === ' '){
            e.preventDefault();
            const modeId = card.dataset.mode;
            toggleModeCard(card);
            if(modeId === 'wip') return;
            selectMode(modeId);
          }
        });
      }

      if(btnPlay){
        btnPlay.addEventListener('click', (e) => {
          e.stopPropagation();
          const modeId = card.dataset.mode;
          if(modeId === 'wip') return;
          selectMode(modeId);
          openModeSettings();
        });
      }

      if(btnInfo){
        btnInfo.addEventListener('click', (e) => {
          e.stopPropagation();
          showO('rulesOverlay');
        });
      }
    });

    if(btnBackToHome) btnBackToHome.addEventListener('click', backToHome);
    if(btnBackToHub) btnBackToHub.addEventListener('click', goToHub);

    // ANCHOR: GLOBAL_SETTINGS_OPEN
    if(btnGlobalSettings) btnGlobalSettings.addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation(); showGlobalSettings(); });
    // ANCHOR: EXIT_TO_MENU (obsługiwane niżej przez BACK_TO_MENU_CONFIRM)

    // ANCHOR: GAME_FLOW_REMOVED (plansza gry + logika rundy wycięte — silnik będzie budowany od zera)



    // ANCHOR: CONFIRM_EVENTS (odpornie na duplikaty)
    if(confirmCancel) confirmCancel.onclick = ()=>{ closeConfirm(); };
    if(confirmOk) confirmOk.onclick = () => { const cb = confirmCb; closeConfirm(); if(cb) cb(); };

    // ANCHOR: CLEAR_DATA (działa zawsze)
    if(btnClearData){
      btnClearData.onclick = () => openConfirm({
        title:'Wyczyścić dane gry?',
        message:'Usunie zapisanych graczy i ustawienia Kalambur na tym urządzeniu.',
        okText:'Wyczyść',
        cancelText:'Anuluj',
        okClass:'btn-reset',
        onConfirm: clearGameData
      });
    }

    // ANCHOR: SETTINGS_CARDS_LOGIC
    function toggleSettingCard(card){
      if(!card) return;
      const isOpen = card.classList.contains('open');
      document.querySelectorAll('#overlayModeSettings .setting-card').forEach(c=>c.classList.remove('open'));
      if(!isOpen) card.classList.add('open');
    }

    function initSettingCards(){
      if(!modeSettingsCards) return;
      modeSettingsCards.querySelectorAll('.setting-card').forEach(card=>{
        const head = card.querySelector('.setting-head');
        if(!head || head.dataset.bound==='1') return;
        head.addEventListener('click', () => toggleSettingCard(card));
        head.addEventListener('keydown', (e) => {
          if(e.key==='Enter' || e.key===' '){ e.preventDefault(); toggleSettingCard(card); }
        });
        head.dataset.bound='1';
      });
    }

    function syncRoundSummary(){
      if(!roundSummary) return;
      const c = state.cfg.classic;
      const parts = [
        (c.turnSeconds===0) ? '∞ czas' : (Number.isFinite(c.turnSeconds) ? `${c.turnSeconds}s` : null),
        (c.targetScore===0) ? '∞ pkt' : (Number.isFinite(c.targetScore) ? `do ${c.targetScore} pkt` : null),
      ].filter(Boolean);
      roundSummary.textContent = parts.join(' • ');
    }

    // ANCHOR: SETTINGS_EVENTS
    if(addPlayerBtn) addPlayerBtn.addEventListener('click', ()=>{ addPlayer(); });
    if(btnRulesOk) btnRulesOk.addEventListener('click', () => { hideO('rulesOverlay'); });
    if(btnGlobalSettingsClose) btnGlobalSettingsClose.addEventListener('click', hideGlobalSettings);
    if(btnEmojiCancel) btnEmojiCancel.addEventListener('click', ()=>{ cancelEmojiPicker(); });

    const btnConfirmEmoji = $('btnConfirmEmoji');
    if(btnConfirmEmoji) btnConfirmEmoji.addEventListener('click', confirmEmojiPicker);
    if(emojiPickerNameInput) emojiPickerNameInput.addEventListener('input', updateEmojiPickerConfirmButton);

    // emoji tabs: delegacja
    if(emojiTabs) emojiTabs.addEventListener('click', (e)=>{
      const b = e.target.closest('[data-emoji-cat]');
      if(!b) return;
      setEmojiCategory(b.dataset.emojiCat);
    });

    // Kategorie
    if(catsGrid) catsGrid.addEventListener('click', (e)=>{ const b=e.target.closest('[data-cat]'); if(b) toggleCategory(b.dataset.cat); });
    if(btnCatsAll) btnCatsAll.addEventListener('click', setAllCategories);
    if(btnCatsRandom) btnCatsRandom.addEventListener('click', randomCategories);
    if(btnCatsNone) btnCatsNone.addEventListener('click', clearCategories);

    if(soundToggle) soundToggle.addEventListener('change', (e)=>setSoundOn(e.target.checked));
    if(soundToggleGame) soundToggleGame.addEventListener('change', (e)=>setSoundOn(e.target.checked));
    if(motionToggle) motionToggle.addEventListener('change', (e)=>setMotionOn(e.target.checked));
    if(cfgTurnSeconds) cfgTurnSeconds.addEventListener('input', readCfgFromUI);
    if(cfgTargetScore) cfgTargetScore.addEventListener('input', readCfgFromUI);

    if(btnStartGame) btnStartGame.addEventListener('click', () => {
      // ANCHOR: START_TO_GAME_OVERLAY (na razie: tylko pusty overlay planszy)
      openGameScreen();
    });
    // ANCHOR: GAME_OVERLAY_EVENTS
    // TOP BAR: zawsze widoczna zębatka ustawień (OSOBNE ustawienia planszy)
    if(btnGameSettings) btnGameSettings.addEventListener('click', (e)=>{
      e.preventDefault();
      e.stopPropagation();
      showGameSettings();
    });

    // ANCHOR: GAME_SETTINGS_EVENTS
    if(btnGameSettingsClose) btnGameSettingsClose.addEventListener('click', hideGameSettings);
    if(btnGameExitToMenu) btnGameExitToMenu.addEventListener('click', ()=>{
      hideGameSettings();
      showOverlay(overlayHome);
    });



    // ANCHOR: CLASS_INSPECTOR_HUD (podgląd klas w UI — łatwiejsze zgłaszanie zmian "zmień .player-pill")
(function setupClassInspectorHud(){
  const hud = document.getElementById('debugHud');
  if(!hud) return;

  const qs = new URLSearchParams(location.search);
  // DEV mode można włączyć od razu parametrem URL: ?dbg=1
  if(qs.get('dbg') === '1') document.body.classList.add('design-debug');

  // HUD ma być widoczny TYLKO w dev mode, ale nasłuch klawiszy działa zawsze (żeby dało się włączyć D)
  hud.classList.toggle('is-hidden', !document.body.classList.contains('design-debug'));

  let pinned = false;
  let currentEl = null;
  let lastCopy = '';
  let toastT = null;

  // ANCHOR: HUD_DRAG (przesuwanie HUD po ekranie)
  const HUD_POS_KEY = 'partyhub_kalambury_hud_pos_v1';
  const clamp = (v,a,b)=>Math.min(b, Math.max(a, v));

  const readHudPos = () => {
    try{
      const raw = localStorage.getItem(HUD_POS_KEY);
      if(!raw) return null;
      const p = JSON.parse(raw);
      if(!p || !Number.isFinite(p.x) || !Number.isFinite(p.y)) return null;
      return { x:p.x, y:p.y };
    }catch(_e){}
    return null;
  };

  const writeHudPos = (x,y) => { try{ localStorage.setItem(HUD_POS_KEY, JSON.stringify({ x, y })); }catch(_e){} };

  const setHudPos = (x,y,{save=true}={}) => {
    const r = hud.getBoundingClientRect();
    const pad = 8;
    const maxX = Math.max(pad, window.innerWidth - r.width - pad);
    const maxY = Math.max(pad, window.innerHeight - r.height - pad);
    const nx = clamp(x, pad, maxX);
    const ny = clamp(y, pad, maxY);

    hud.style.left = Math.round(nx) + 'px';
    hud.style.top = Math.round(ny) + 'px';
    hud.style.right = 'auto';
    hud.style.bottom = 'auto';

    if(save) writeHudPos(nx, ny);
  };

  const resetHudPos = () => {
    try{ localStorage.removeItem(HUD_POS_KEY); }catch(_e){}
    hud.style.left = '';
    hud.style.top = '';
    hud.style.right = '';
    hud.style.bottom = '';
  };

  // init pos (jeśli było zapisane)
  (function initHudPos(){
    const p = readHudPos();
    if(p) setHudPos(p.x, p.y, { save:false });
  })();

  window.addEventListener('resize', ()=>{
    const p = readHudPos();
    if(p) setHudPos(p.x, p.y, { save:false });
  });

  let dragging = null;

  const dragStart = (e) => {
    if(e.button !== 0) return;
    const head = e.target && e.target.closest ? e.target.closest('.dh-head') : null;
    if(!head) return;

    // ustaw bazę w px (zamiast left+bottom)
    const r = hud.getBoundingClientRect();
    if(!hud.style.left || !hud.style.top){
      hud.style.left = Math.round(r.left) + 'px';
      hud.style.top = Math.round(r.top) + 'px';
      hud.style.right = 'auto';
      hud.style.bottom = 'auto';
    }

    const baseL = parseFloat(hud.style.left) || r.left;
    const baseT = parseFloat(hud.style.top) || r.top;

    dragging = { id:e.pointerId, startX:e.clientX, startY:e.clientY, baseL, baseT };
    hud.classList.add('dragging');
    try{ hud.setPointerCapture(e.pointerId); }catch(_e){}
    e.preventDefault();
  };

  const dragMove = (e) => {
    if(!dragging || e.pointerId !== dragging.id) return;
    const dx = e.clientX - dragging.startX;
    const dy = e.clientY - dragging.startY;
    setHudPos(dragging.baseL + dx, dragging.baseT + dy, { save:false });
    e.preventDefault();
  };

  const dragEnd = (e) => {
    if(!dragging || e.pointerId !== dragging.id) return;
    const r = hud.getBoundingClientRect();
    setHudPos(r.left, r.top, { save:true });
    dragging = null;
    hud.classList.remove('dragging');
    try{ hud.releasePointerCapture(e.pointerId); }catch(_e){}
    e.preventDefault();
  };

  hud.addEventListener('pointerdown', dragStart);
  hud.addEventListener('pointermove', dragMove);
  hud.addEventListener('pointerup', dragEnd);
  hud.addEventListener('pointercancel', dragEnd);

  // ANCHOR: HUD_COPY (kopiowanie do schowka)
  const copyText = async (txt) => {
    try{
      if(navigator.clipboard && navigator.clipboard.writeText){
        await navigator.clipboard.writeText(txt);
        return true;
      }
    }catch(_e){}

    try{
      const ta = document.createElement('textarea');
      ta.value = String(txt || '');
      ta.setAttribute('readonly','');
      ta.style.position = 'fixed';
      ta.style.left = '-9999px';
      ta.style.top = '-9999px';
      document.body.appendChild(ta);
      ta.focus();
      ta.select();
      const ok = document.execCommand && document.execCommand('copy');
      ta.remove();
      return !!ok;
    }catch(_e){}
    return false;
  };

  const toastCopied = () => {
    hud.classList.add('copied');
    if(toastT) clearTimeout(toastT);
    toastT = setTimeout(()=>hud.classList.remove('copied'), 650);
  };

  const isTyping = () => {
    const a = document.activeElement;
    if(!a) return false;
    const t = (a.tagName || '').toLowerCase();
    return t === 'input' || t === 'textarea' || a.isContentEditable;
  };

  const clsText = (el) => {
    const list = el && el.classList ? [...el.classList] : [];
    return list.length ? list.map(c => '.' + c).join(' ') : '(brak)';
  };

  const setHud = (el) => {
    if(!el) return;
    const tag = (el.tagName || '').toLowerCase();
    const id = el.id ? ('#' + el.id) : '(brak)';
    const dbg = el.getAttribute && el.getAttribute('data-dbg');
    const dbg2 = el.getAttribute && el.getAttribute('data-dbg2');
    const extra = [
      dbg ? `data-dbg="${dbg}"` : null,
      dbg2 ? `data-dbg2="${dbg2}"` : null
    ].filter(Boolean).join(' • ');

    // SIZE (px): realny rozmiar w layoucie — to samo co widzisz na ekranie
    const r = (el.getBoundingClientRect ? el.getBoundingClientRect() : { width:0, height:0 });
    const w = Math.round(r.width);
    const h = Math.round(r.height);
    const size = `${w}×${h}px`;

    // string do kopiowania (C / dwuklik w HUD)
    const cls = clsText(el);
    const extraCopy = extra ? (' | ' + extra.split(' • ').join(' | ')) : '';
    lastCopy = `TAG:<${tag}> | ID:${id} | CLASS:${cls} | SIZE:${size}${extraCopy}`;

    hud.innerHTML =
      `<div class="dh-line dh-head"><span class="dh-head-left"><span class="dh-drag" title="Przeciągnij (dblklik reset)" aria-hidden="true">⠿</span><b>&lt;${tag}&gt;</b></span> <span class="dh-badge">${pinned ? 'PIN' : 'HOVER'}</span></div>` +
      `<div class="dh-line"><span class="dh-muted">ID:</span> ${id}</div>` +
      `<div class="dh-line"><span class="dh-muted">CLASS:</span> <span class="dh-classes">${clsText(el)}</span></div>` +
      `<div class="dh-line"><span class="dh-muted">SIZE:</span> ${size}</div>` +
      (extra ? `<div class="dh-line"><span class="dh-muted">${extra}</span></div>` : '') +
      `<div class="dh-tip"><kbd>P</kbd>pin <kbd>D</kbd>debug <kbd>S</kbd>stage <kbd>C</kbd>copy</div>`;
  };

  // Preferuj "sensowne" elementy (komponenty), a nie np. img.emoji z twemoji
  const pick = (t) => {
    if(!t) return null;
    if(t === hud || (hud.contains && hud.contains(t))) return null;

    const base = (t.nodeType === 1) ? t : (t.parentElement || null);
    if(!base) return null;
    if(base === document.body || base === document.documentElement) return null;

    const sel =
      '[data-dbg2],[data-dbg],' +
      '.player-pill,.player-row,' +
      '.mode-card,.mode-header,' +
      '.settings-container,.setting-card,.setting-head,' +
      '.cat-chip,.emoji-btn,.emoji-tab,' +
      'button,input,textarea,select,label';

    const best = (base.closest && base.closest(sel)) ? base.closest(sel) : base;
    if(!best || best === document.body || best === document.documentElement) return null;
    if(best === hud || (hud.contains && hud.contains(best))) return null;
    return best;
  };

  // Stabilne odświeżanie: pointer events + RAF
  let raf = 0;
  let pendingT = null;

  const onMove = (e) => {
    if(pinned) return;
    if(!document.body.classList.contains('design-debug')) return;

    pendingT = e.target;
    if(raf) return;

    raf = requestAnimationFrame(() => {
      raf = 0;
      const el = pick(pendingT);
      if(!el) return;
      if(el === currentEl) return;
      currentEl = el;
      setHud(el);
    });
  };

  document.addEventListener('pointermove', onMove, true);
  document.addEventListener('pointerover', onMove, true);

  // dwuklik w HUD kopiuje aktualny opis
  hud.addEventListener('dblclick', async (e)=>{
    // dblklik na uchwycie: reset pozycji
    if(e && e.target && e.target.closest && e.target.closest('.dh-drag')){
      e.preventDefault();
      e.stopPropagation();
      resetHudPos();
      return;
    }

    // dblklik gdziekolwiek indziej: kopiuj opis
    if(!lastCopy) return;
    const ok = await copyText(lastCopy);
    if(ok) toastCopied();
  });

  window.addEventListener('keydown', (e) => {
    if(isTyping()) return;
    const k = (e.key || '').toLowerCase();

    if(k === 'p'){
      pinned = !pinned;
      if(!currentEl){
        const seed0 = document.querySelector('.overlay.is-visible') || document.querySelector('#overlayGame') || document.body;
        currentEl = seed0;
      }
      setHud(currentEl);
    }

    if(k === 'd'){
      document.body.classList.toggle('design-debug');
      const on = document.body.classList.contains('design-debug');

      // Reset pin po przełączeniu, żeby HUD nie wyglądał jak "zepsuty"
      pinned = false;
      currentEl = null;
      document.body.classList.remove('dev-ui');

      hud.classList.toggle('is-hidden', !on);

      if(on){
        const seed = document.querySelector('.overlay.is-visible') || document.querySelector('#overlayGame') || document.body;
        currentEl = seed;
        setHud(seed);
      }
    }

    if(k === 's'){
      // DEV: pokaż/ukryj select stage (tylko gdy design-debug)
      if(!document.body.classList.contains('design-debug')) return;
      document.body.classList.toggle('dev-ui');
      const on = document.body.classList.contains('dev-ui');
      if(on){
        try{ initDevStageSelect(); }catch(_e){}
        setTimeout(()=>{ if(devStageSelect) devStageSelect.focus(); }, 0);
      }
      if(currentEl) setHud(currentEl);
    }

    if(k === 'c'){
      if(!lastCopy) return;
      copyText(lastCopy).then(ok=>{ if(ok) toastCopied(); });
    }
  });

  // init
  const seed = document.querySelector('.overlay.is-visible') || document.querySelector('#overlayGame') || document.body;
  currentEl = seed;
  setHud(seed);
})();


// ANCHOR: DESIGN_DEBUG_TAG_OFFSETS (żeby tagi data-dbg/data-dbg2 nie nakładały się na siebie)
(function setupDebugTagOffsets(){
  const STEP_Y = 18; // px — odstęp między tagami w zagnieżdżeniach

  const apply = () => {
    const on = document.body.classList.contains('design-debug');
    const els = document.querySelectorAll('[data-dbg],[data-dbg2]');

    els.forEach(el=>{
      if(!on){
        el.style.removeProperty('--dbgTagShiftX');
        el.style.removeProperty('--dbgTagShiftY');
        return;
      }

      // depth = ile "debug kontenerów" jest nad tym elementem
      let depth = 0;
      let p = el.parentElement;
      while(p){
        if(p.hasAttribute('data-dbg') || p.hasAttribute('data-dbg2')) depth++;
        p = p.parentElement;
      }

      el.style.setProperty('--dbgTagShiftX', '0px');
      el.style.setProperty('--dbgTagShiftY', (depth * STEP_Y) + 'px');
    });
  };

  // init + reaguj na przełączenie debug (klasa na <body>)
  apply();
  const mo = new MutationObserver(()=>apply());
  mo.observe(document.body, { attributes:true, attributeFilter:['class'] });
})();


    // INIT
    loadSettings();

    // domyślnie: respektuj ustawienie systemu (jeśli user nie zapisał jeszcze własnego)
    if(!motionWasSaved){
      const sysReduce = !!(window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches);
      state.settings.motionOn = !sysReduce;
    }

    applySettingsToUI();
    loadCfg();
    applyCfgToUI();
    renderCategories();
    loadMode();

    if(txtVersion) txtVersion.textContent = GAME_VERSION;
    if(homeVersion) homeVersion.textContent = 'Wersja: ' + GAME_VERSION;

    showOverlay(overlayHome);
    renderPlayers();
    validateStart();

    // ANCHOR: DEV_STAGE_INIT
    initDevStageSelect();

    // ANCHOR: TWEMOJI_BOOT
    whenTwemojiReady(()=>{
      renderPlayers();
      const ep = $('emojiPickerOverlay');
      if(ep && ep.classList.contains('is-visible')) renderEmojiGrid();
    });

    // ANCHOR: DEV_TESTS (uruchamiane tylko przy ?test=1)
    (function runDevTests(){
      const qs = new URLSearchParams(location.search);
      if(qs.get('test') !== '1') return;
      const assert = (cond, msg) => { if(!cond) throw new Error('TEST FAIL: ' + msg); };

      assert(!!$('overlayHome'), 'overlayHome istnieje');
      assert(!!$('overlayModeSettings'), 'overlayModeSettings istnieje');
      assert(!!$('globalSettingsOverlay'), 'globalSettingsOverlay istnieje');
      assert(typeof showOverlay === 'function', 'showOverlay istnieje');
      assert(typeof clearGameData === 'function', 'clearGameData istnieje');

      // showOverlay nie powinno rzucać wyjątku
      try{ showOverlay($('overlayHome')); }catch(e){ assert(false, 'showOverlay nie powinno rzucać: ' + e.message); }

      console.log('DEV TESTS: OK');
    })();
  </script>
</body>
</html>


